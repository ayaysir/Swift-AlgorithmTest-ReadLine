//
//  3015.swift
//  AlgorithmTest-ReadLine
//
//  Created by 윤범태 on 3/29/2024.
//
//  5: 오아시스 재결합 https://www.acmicpc.net/problem/3015
//

import Foundation

/// 오아시스 재결합 https://www.acmicpc.net/problem/3015
func Q_3015() {
    let n = Int(readLine()!)!
    var attendances = Array(repeating: (0, 0), count: n)
    // var freqs = [Int : Int]()
    var stack = [(Int, Int)]()
    var result = 0
    
    for i in 0..<n {
        let height = Int(readLine()!)!
        attendances[i].0 = height
        // freqs[height, default: 0] += 1
        // attendances[i].1 = freqs[height]!
    }
    
    for attendance in attendances {
        var newFreq = 1
        while let last = stack.last, last.0 <= attendance.0 {
            if last.0 < attendance.0 {
                result += last.1
                stack.removeLast()
            } else if last.0 == attendance.0 {
                result += last.1
                newFreq = last.1 + 1 // ??
                stack.removeLast()
            }
            
        }
        
        if !stack.isEmpty {
            result += 1
        }
        
        stack.append((attendance.0, newFreq))
    }
    
    print(result)
}

/*
 [풀이] https://justicehui.github.io/coi/2018/11/06/BOJ3015/
 * 스택의 진행
  - 단조 감소: 집합이 갈수록 같거나 작아진다.
  - 순감소: 집합이 갈수록 작아진다.
 
 * 스택에 있는 원소들은 단조 감소 혹은 순감소 상태를 유지
  - 순감소 상태를 선택
 
 * (키: Int, 동일한_키_가진_사람의_수: Int)
  - 키가 순감소 상태 유지, 중복값 없게
  - 현재 값보다 스택의 top에 있는 값이 더 작거나 같으면 pop
 
 * 순감소 상태를 유지
  1. 스택 안에 있는 사람은 나중에 들어올 사람들이 볼 가능성이 있는 사람
  2. 이미 스택에서 pop된 사람은 나중에 들어오는 사람들이 절대 볼 수 없는 사람
 
 * top의 키보다 now의 키가 크다면
  - now보다 나중에 들어오는 사람은 절대로 top을 볼 수 없음 (=> now가 top보다 더 크니까 가려져서)
  - top보다 작은 now가 나올 때까지 반복합니다.
   - 주의: pair의 second값은 중복되는 원소의 개수를 의미
     - now와 top이 같은 경우에도 pop
     - pop을 할 때는 1이 아닌 top의 second값만큼 정답을 증가
  - 스택에 now를 삽입. 이 때, '스택이 비어있지 않으면' top이 now를 볼 수 있으므로 정답을 1 증가
 
 [while문에서 같은 중복값을 만났을 때 출현 빈도를 증가시키는 이유]
 https://lotuslee.tistory.com/105
 
 - 예제에서 4번째 사람의 차례이고 현재 스택에는 2번째 사람의 키 정보와 3번째 사람의 키 정보가 들어있다고 하자.
 - 스택: [4, 1] / 4번째 사람: 1
 - 스택의 top은 1이 있고, 새로 들어온 4번째 사람의 키도 1이다. 별도 처리를 하지 않았다면
    - 스택이 내림차순을 유지해야 하므로 스택에서 top에 있는 사람을 pop한다.
    - 그리고 카운트를 1 증가시킨다.
    - 그 다음의 top에는 키가 4인 사람이 있으므로 자신보다 크기 때문에 더 이상 pop하지 않고,
    - 카운트를 하나 더 증가시키고 자기 자신을 push한다.
    - 따라서, 총 카운트는 2가 증가한다.
 - 이제, 5번째 사람이 새로 줄을 섰다고 하자. 마찬가지로 이 때의 카운트는 2가 증가한다.
    s: [2, 4, 1] / 2 => s: [2, 4] + [2] = [2, 4, 2]
 - 여기서 문제가 발생한다.
    - 원래대로라면 5번째 사람의 앞에 있는 사람들 중 볼 수 있는 사람은 총 3명 (4, 1, 1)이다.
    - 자신 앞에 키가 1인 사람이 둘이 있었기 때문이다.
    - 하지만 이 직전에 스택에서 키가 1인 사람을 pop했기 때문에 카운트가 3이 아니라 2만 증가하게 되었다.
 - 스택에서 pop할 때마다 자신의 키와 같은 키의 사람을 만나면 pair의 cnt를 하나씩 증가시킨다.
 - 카운트를 증가시킬 때는 스택의 top에 있는 Pair객체의 cnt값만큼 더해주도록 한다.
   - 최초 풀이에서 사용했던 freqs 및 관련 내용은 애초에 필요가 없었다.
   - 이미 스택에서 들어갈 때 출현 빈도는 1로 초기화되어 들어감
 
 따라서, 총 카운트는 2가 증가한다.
 
 [문제 자체를 이해 못함]
  - 왜 아래 그림에서 10쌍이 답인가?
 
                       🙋‍♂️
       🙆‍♀️              🟪
       🟥              🟪
   🙆  🟥      🙋  🙋‍♀️  🟪
   🟩  🟥  🙆‍♂️  🟦  🟧  🟪  💁‍♀️
 
 
 2️⃣4️⃣⬜️⬜️⬜️⬜️⬜️
 ⬜️4️⃣1️⃣⬜️⬜️⬜️⬜️
 ⬜️⬜️1️⃣2️⃣⬜️⬜️⬜️
 ⬜️4️⃣⬜️2️⃣⬜️⬜️⬜️
 ⬜️⬜️⬜️2️⃣2️⃣⬜️⬜️
 ⬜️4️⃣⬜️⬜️2️⃣⬜️⬜️
 ⬜️⬜️⬜️⬜️2️⃣5️⃣⬜️
 ⬜️⬜️⬜️2️⃣⬜️5️⃣⬜️
 ⬜️4️⃣⬜️⬜️⬜️5️⃣⬜️
 ⬜️⬜️⬜️⬜️⬜️5️⃣1️⃣
 
 ---------
 
 문제
 오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.

 이 역사적인 순간을 맞이하기 위해 줄에서서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해 졌다.

 두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.

 줄에 서있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.

 입력
 첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)

 둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 2^31 나노미터 보다 작다.

 사람들이 서 있는 순서대로 입력이 주어진다.

 출력
 서로 볼 수 있는 쌍의 수를 출력한다.

 예제 입력 1
7
2
4
1
2
2
5
1
 
 예제 출력 1
 10

 */
