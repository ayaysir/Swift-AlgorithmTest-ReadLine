//
//  12015.swift
//  AlgorithmTest-ReadLine
//
//  Created by 윤범태 on 3/25/2024.
//
//  7: 가장 긴 증가하는 부분 수열 2 https://www.acmicpc.net/problem/12015
//

import Foundation

/// 가장 긴 증가하는 부분 수열 2 https://www.acmicpc.net/problem/12015
func Q_12015() {
    _ = readLine()
    let numbers = readLine()!.split(separator: " ").map { Int($0)! }
    var lis = [numbers.first!]
    
    for i in 1..<numbers.count {
        if let replaceIndex = binarySearch(numbers[i]) {
            lis[replaceIndex] = numbers[i]
        } else if numbers[i] > lis.last! {
            lis.append(numbers[i])
        }
        // print(lis, numbers[i])
    }
    
    print(lis.count)
       
    func binarySearch(_ number: Int) -> Int? {
        var (start, end) = (0, lis.count) // lis.count - 1 아님
        
        var result: Int? = nil
        while start < end {
            let mid = (start + end) / 2
            
            if lis[mid] == number {
                return nil
            }
            
            if number < lis[mid] {
                result = mid // 후보
                end = mid
            } else {
                start = mid + 1
            }
        }
        
        return result
    }
}

/*
 [풀이] https://st-lab.tistory.com/285
 - LIS, 즉 가장 긴 증가하는 부분 수열이라함은 결국 중점이 '증가' 한다는 것과 '가장 길다' 는 것이다.
   - 증가의 의미: 선행 원소보다 후행 원소가 커야 한다.
   - 가장 길다의 의미: 제한된 수의 범위 내에서 볼 때 상호 원소간 값의 차이가 적어야 한다.
 - 이러한 조건을 만족해야 카운트가 많은 수열을 만들 수 있다.
 
 (예) {10, 20, 30, 15, 20, 30, 50, 40, 45, 60}
 {10, 20, 30} 부분에서 15를 어떻게 처리?
  - 30보다는 크지 않으나 앞의 10과의 상호 원소값의 차이가 30보다 적으므로 (20 - 10 = 10 > 15 - 10 = 5)
  - 대치한다. =>  {10, 15, 30}
  - 이런 식의 작업을 반복하며, 이 반복 작업에 이분 탐색을 사용한다.
    - binarySearch(number)를 통해 대치할 공간이 발견되었다면 대치
    - 대치할 공간이 발견되지 않았다면(nil) 맨 마지막 원소보다 큰 경우에만 추가 (증가 수열이므로)
 
 +--------------------------+--------+-----------+------------------------------+
 | LIS                      | 탐색값   | 추가/대치   | 결과                          |
 +--------------------------+--------+-----------+------------------------------+
 | {10}                     | 20     | 추가       | {10, 20}                     |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 20}                 | 30     | 추가       | {10, 20, 30}                 |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 20, 30}             | 15     | 대치       | {10, 15, 30}                 |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 15, 30}             | 20     | 대치       | {10, 15, 20}                 |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 15, 20}             | 30     | 추가       | {10, 15, 20, 30}             |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 15, 20, 30}         | 50     | 추가       | {10, 15, 20, 30, 50}         |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 15, 20, 30, 50}     | 40     | 대치       | {10, 15, 20, 30, 40}         |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 15, 20, 30, 40}     | 45     | 추가       | {10, 15, 20, 30, 40, 45}     |
 +--------------------------+--------+-----------+------------------------------+
 | {10, 15, 20, 30, 40, 45} | 60     | 추가       | {10, 15, 20, 30, 40, 45, 60} |
 +--------------------------+--------+-----------+------------------------------+
 
 [주의]
 end = array.count와 array.count - 1중 둘 중 뭐가 맞냐?
 - end를 갱신할 때 end = mid - 1로 하면 array.count - 1을 선택 후 while문의 조건을 start <= end로 (1920번 문제)
 - end를 갱신할 때 end = mid로 하면 array.count를 선택 후 while문의 조건을 start < end로 (10816번 문제)
 (직접 그려가면서 확인)
 -------------
 
 문제
 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

 입력
 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

 출력
 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

 예제 입력 1
 6
 
 10 20 10 30 20 50
 예제 출력 1
 4
 
 [반례]
 https://www.acmicpc.net/board/view/32030
 */
