//
//  7579.swift
//  AlgorithmTest-ReadLine
//
//  Created by 윤범태 on 3/27/2024.
//
//  6: 앱 https://www.acmicpc.net/problem/7579
//

import Foundation

/// 앱 https://www.acmicpc.net/problem/7579
func Q_7579() {
    let r = readLine()!.split(separator: " ").map { Int($0)! }
    let (n, m) = (r[0], r[1])
    let a = [0] + readLine()!.split(separator: " ").map { Int($0)! }
    let c = [0] + readLine()!.split(separator: " ").map { Int($0)! }
    
    var dp = Array(repeating: Array(repeating: 0, count: 10001), count: 101)
    var answer = Int.max
    
    for i in stride(from: 1, through: n, by: 1) {
        for j in stride(from: 0, through: 10000, by: 1) {
            if c[i] > j { // cost가 비용 j 보다 크면
                dp[i][j] = dp[i-1][j]
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-c[i]] + a[i])
                
                if dp[i][j] >= m {
                    answer = min(answer, j)
                    print(answer, j)
                }
            }
            
        }
    }
    
    print(answer)
    for i in 0...n {
        print(dp[i][...20])
    }
}

/*
 [풀이] https://velog.io/@cocoral/백준-C-7579번-앱
 배낭 알고리즘
  - DP[i][cost]는 1~i번째까지의 배낭을 고려했을 때 cost의 비용으로 얻을 수 있는 최대 가치(=> 메모리 용량)를 의미
  - cost[i]가 j(DP의 비용)보다 크다면 DP[i-1][j]를 그대로 가져와서 쓰면 되고,
  - 그렇지 않다면 DP[i-1][j](i번째 배낭을 선택하지 않은 경우)와
     DP[i-1][j-cost[i]] + memory[i] 중 최댓값을 구하면 된다.
  - 적어도 M바이트를 넘는 최소 비용을 찾아야 하기 때문에, 메모리 바이트 수 memory[i]를 더하고 풀면 된다.
  - 비용이 주 문제이기 때문에 가치가 M 이상일 때의 최소 비용을 구해주면 된다.
 
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 |        |        ║  0  |  1  |  2  |  3  |  4  |  5  |  6  |
 +========+========+=====+=====+=====+=====+=====+=====+=====+
 |  BYTE  |  COST  ║  0  |  0  |  0  |  0  |  0  |  0  |  0  |
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 |   30   |   3    ║  0  |  0  |  0  | 30  | 30  | 30  | 30  |
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 |   10   |   0    ║  0  | 10  | 10  | 40  | 40  | 40  | 40  |
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 |   20   |   3    ║  0  | 10  | 10  | 40  | 40  | 40  | 40  |
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 |   35   |   5    ║  0  | 10  | 10  | 40  | 40  | 40  | 60  |
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 |   40   |   4    ║  0  | 10  | 10  | 40  | 40  | 50  | 60  |
 +--------+--------+-----+-----+-----+-----+-----+-----+-----+
 
 ---------
 
 문제
 (...)
 현재 N개의 앱, A1, ..., AN이 활성화 되어 있다고 가정하자. 이들 앱 Ai는 각각 mi 바이트만큼의 메모리를 사용하고 있다. 또한, 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우, 추가적으로 들어가는 비용(시간 등)을 수치화 한 것을 ci 라고 하자. 이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여, 추가로 M 바이트의 메모리가 필요하다고 하자. 즉, 현재 활성화 되어 있는 앱 A1, ..., AN 중에서 몇 개를 비활성화 하여 M 바이트 이상의 메모리를 추가로 확보해야 하는 것이다. 여러분은 그 중에서 비활성화 했을 경우의 비용 ci의 합을 최소화하여 필요한 메모리 M 바이트를 확보하는 방법을 찾아야 한다.
 
 입력
 입력은 3줄로 이루어져 있다. 첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다. 둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며, 셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다

 단, 1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000,000이며, 1 ≤ m1, ..., mN ≤ 10,000,000을 만족한다. 또한, 0 ≤ c1, ..., cN ≤ 100이고, M ≤ m1 + m2 + ... + mN이다.

 출력
 필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다.

 예제 입력 1
 5 60
 30 10 20 35 40
 3 0 3 5 4
 
 예제 출력 1
 6
 */
