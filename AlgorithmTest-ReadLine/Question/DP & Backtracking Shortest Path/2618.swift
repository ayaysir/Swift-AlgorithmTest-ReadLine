//
//  2618.swift
//  AlgorithmTest-ReadLine
//
//  Created by 윤범태 on 4/8/2024.
//
//  5: 경찰차 https://www.acmicpc.net/problem/2618
//

import Foundation

/// 경찰차 https://www.acmicpc.net/problem/2618
func Q_2618() {
    let n = Int(readLine()!)!
    let w = Int(readLine()!)!
    /// 사건이 발생된 지점 목록
    let p: [(y: Int, x: Int)] = (0..<w).map { _ in
        let r = readLine()!.split(separator: " ").map { Int($0)! }
        return (y: r[0], x: r[1])
    }
    
    var dp = Array(repeating: Array(repeating: -1, count: w + 2), count: w + 2)
    var paths = Array(repeating: Array(repeating: -1, count: w + 2), count: w + 2)
    
    func calculateDistance(police: Int, target: Int, start: Int) -> Int {
        var policePos = (y: 0, x: 0)
        var targetPos = (y: 0, x: 0)
        
        if start == 1 {
            policePos = (1, 1)
        } else if start == 2 {
            policePos = (n, n)
        } else {
            policePos = p[police - 1]
        }
        
        targetPos = p[target - 1]
        
        return abs(policePos.y - targetPos.y) + abs(policePos.x - targetPos.x)
    }
    
    /// 1: 최소 거리 찾기
    func findDistance(p1: Int, p2: Int) -> Int {
        guard p1 < w, p2 < w else {
            return 0
        }
        
        guard dp[p1][p2] == -1 else {
            return dp[p1][p2]
        }
        
        let move = max(p1, p2) + 1
        
        var (nextP1Dist, nextP2Dist) = (0, 0)
        nextP1Dist = findDistance(p1: move, p2: p2) + calculateDistance(police: p1, target: move, start: p1 == 0 ? 1 : 0)
        nextP2Dist = findDistance(p1: p1, p2: move) + calculateDistance(police: p2, target: move, start: p2 == 0 ? 2 : 0)
        
        dp[p1][p2] = min(nextP1Dist, nextP2Dist)
        paths[p1][p2] = nextP1Dist < nextP2Dist ? 1 : 2
        
        return min(nextP1Dist, nextP2Dist)
    }
    
    print(findDistance(p1: 0, p2: 0))
    
    // 2: 경로 구하기
    var (x, y) = (0, 0)
    var pathResult = ""
    
    for i in 0..<w {
        pathResult.write("\(paths[x][y])\n")
        
        if paths[x][y] == 1 {
            x = i + 1
        } else {
            y = i + 1
        }
    }
    
    print(pathResult)
}

/*
 [풀이] https://source-sc.tistory.com/53
 (1) DFS + DP를 이용해 최소 거리 계산
 (2) 산출물인 PATHS 테이블을 이용해 경찰이 맡은 사건 (경로) 출력
 
 [문제 예제를 통한 분석]
 ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣
 1️⃣🚔⬜️⬜️⬜️⬜️⬜️
 2️⃣⬜️⬜️💥⬜️⬜️⬜️
 3️⃣⬜️⬜️⬜️⬜️💥⬜️
 4️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 5️⃣⬜️⬜️⬜️⬜️💥⬜️
 6️⃣⬜️⬜️⬜️⬜️⬜️🚔
 - 경찰차는 (1, 1) 그리고 (6, 6)에 위치해있고
 - 3개의 사건이 분포되어있다. 1:(3, 5) 2:(5, 5) 3:(2, 3)
 
 (1) 첫번째 사건의 처리
  - 1번 경찰차가 6칸을 이동하여 처리하거나
  - 2번 경찰차가 4칸을 이동하여 처리
 ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣        ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣
 1️⃣🚔🟧🟧🟧🟧⬜️        1️⃣🚔⬜️⬜️⬜️⬜️⬜️
 2️⃣⬜️⬜️💥⬜️🟧⬜️        2️⃣⬜️⬜️💥⬜️⬜️⬜️
 3️⃣⬜️⬜️⬜️⬜️✴️⬜️        3️⃣⬜️⬜️⬜️⬜️✴️🟧
 4️⃣⬜️⬜️⬜️⬜️⬜️⬜️        4️⃣⬜️⬜️⬜️⬜️⬜️🟧
 5️⃣⬜️⬜️⬜️⬜️💥⬜️        5️⃣⬜️⬜️⬜️⬜️💥🟧
 6️⃣⬜️⬜️⬜️⬜️⬜️🚔        6️⃣⬜️⬜️⬜️⬜️⬜️🚔
 
 브루트포스로 처리시 2^w: w = 1000인 경우 2^1000으로 불가
 
 (2) DP 사용
 만약 DP를 사용해서 10번까지의 사건 중 5번까지만 사건 파악이 되었고 나머지는 배정이 되지 않았다면
 ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟
 1️⃣✔️✔️⬜️✔️✅
 2️⃣⬜️⬜️✅⬜️⬜️
 - (1~5)번까지의 경우의 수 2^5, (6~10)번도 경우의 수 2^5
 - 가장 중요한 포인트중 하나는 현재 진행 상태를 각 경찰차들의 마지막으로 맡은 사건으로 표현할 수 있다는 점이다.
   - 1,2,4,5 번사건을 1번 경찰차가, 3번 사건을 2번 경찰차가 담당
 - 1번과 2번의 결과 경우의 수를 알아보면 2^2 = 4 가지가 나온다.
   - 그러나 그 결과 모두 5번까지 봤을 때 경찰차 1, 2가 마지막으로 맡은 사건은 동일하다. (초록 체크박스)
   - 즉, 1번과 2번의 결과가 어찌되더라도 이후 6~10까지의 결과값은 모두 동일할 것이므로 4번 모두 시행해 볼 필요가 없다.
 - 따라서 2차원 배열로 각 경찰차들의 최종 사건을 파라미터로 최소값을 저장하여 DFS에서 DP를 설계한다.
 
 (3) 경로 추적
 - 만약 위의 DP를 활용하여 최솟값과 해당 사건 처리 결과를 string이나 다른 형태로 저장한다고 해도
    w^3 = 1000^3 바이트만큼의 메모리를 요구하며 128mb인 문제의 메모리 조건을 뛰어넘게 될것이다.
 - 현재 경찰차들의 마지막 사건번호를 통해 해당 사건번호일 때 이후에 최소거리를 만들수 있는 경찰차를 기록한다.
 
 예) 사건은 총 4개이며
  - 현재까지 1번 사건을 1번 경찰차가, 2번 사건을 2번 경찰차가 수행했다고 가정할 때,
  - 이후 2번 경찰차가 3번 사건을 담당하는 것이 최소거리를 만든다고 하면
  - (1,2) 지점의 값은 2(🚨)가 된다.
 
 ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣
 1️⃣⬜️🚨⬜️⬜️⬜️⬜️
 2️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 3️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 4️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 5️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 6️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 해당 지점에는 다음 사건을 담당해야 할 경찰차의 번호가 들어가야한다.
 
 ⬜️1️⃣2️⃣3️⃣4️⃣
 1️⃣✔️⬜️⬜️⬜️
 2️⃣⬜️✔️✅⬜️
 
 그리고 3번 사건을 2번 경찰차가 담당한 후 4번째 사건을 담당해야 할 경찰차의 번호가 (1,3) 지점에 들어가야한다.
 - (1, 3) 지점의 값은 1 (🚓)이 된다.
 ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣
 1️⃣⬜️⬜️🚓⬜️⬜️⬜️
 2️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 3️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 4️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 5️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 6️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 
 ⬜️1️⃣2️⃣3️⃣4️⃣
 1️⃣✔️⬜️⬜️✅
 2️⃣⬜️✔️✔️⬜️
 
 - DFS를 통해 뿌리까지 탐색하는 동안 minimum 값이 도출될 때마다
 - 현재 경찰차들의 마지막 담당 사건 번호 2가지로 이후 다음 사건을 담당해야 할 경찰차의 번호를 넣음으로써
 - 최종적으로 모든 사건의 담당 경찰차 순서를 구할 수 있다.
 
 -------
 
 문제
 어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.

 모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다. N이 6인 경우의 예를 들면 다음과 같다.

 ⬜️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣
 1️⃣🚔⬜️⬜️⬜️⬜️⬜️
 2️⃣⬜️⬜️💥⬜️⬜️⬜️
 3️⃣⬜️⬜️⬜️⬜️💥⬜️
 4️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 5️⃣⬜️⬜️⬜️⬜️💥⬜️
 6️⃣⬜️⬜️⬜️⬜️⬜️🚔

 이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차2로 부른다. 처음에는 항상 경찰차1은 (1, 1)의 위치에 있고 경찰차2는 (N, N)의 위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고, 연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.

 예를 들어 앞의 그림처럼 N=6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치 를 순서대로 (3, 5), (5, 5), (2, 3)이라고 하자. (3, 5)의 사건을 경찰차2에 맡기고 (5, 5)의 사건도 경찰차2에 맡기며, (2, 3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되 고, 더 이상 줄일 수는 없다.

 처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.

 입력
 첫째 줄에는 동서방향 도로의 개수를 나타내는 정수 N(5 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 처리해야 하는 사건의 개수를 나타내는 정수 W(1 ≤ W ≤ 1,000)가 주어진다. 셋째 줄부터 (W+2)번째 줄까지 사건이 발생된 위치가 한 줄에 하나씩 주어진다. 경찰차들은 이 사건들을 주어진 순서대로 처리해야 한다. 각 위치는 동서방향 도로 번호를 나타내는 정수와 남북방향 도로 번호를 나타내는 정수로 주어지며 두 정수 사이에는 빈칸이 하나 있다. 두 사건이 발생한 위치가 같을 수 있다.

 출력
 첫째 줄에 두 경찰차가 이동한 총 거리를 출력한다. 둘째 줄부터 시작하여 (i+1)번째 줄에 i(1 ≤ i ≤ W)번째 사건이 맡겨진 경찰차 번호 1 또는 2를 출력한다.

 예제 입력 1
 6
 3
 3 5
 5 5
 2 3
 
 예제 출력 1
 9
 2
 2
 1
 */
