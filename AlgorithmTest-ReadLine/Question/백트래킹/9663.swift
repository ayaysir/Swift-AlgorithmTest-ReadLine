//
//  9663.swift
//  AlgorithmTest-ReadLine
//
//  Created by 윤범태 on 3/16/24.
//

import Foundation

func Q_9663() {
    // 체스의 퀸: 가로세로 대각선으로 무한이동 할 수 있음
    
    let n = Int(readLine()!)!
    var board = Array(repeating: -1, count: 15)
    var visited = Array(repeating: false, count: 15)
    var result = 0
    
    func isSafe(at r: Int) -> Bool {
        // r 이전 행을 순회하면서 =>
        for i in 0..<r {
            // r - i는 무조건 양수
            // 대각선상에 board에 배치된 퀸이 있다면 죽음
            // 인덱스 자체는 행, board[인덱스]는 열을 의미 (하단 해설 참고)
            if r - i  == abs(board[r] - board[i]) {
                return false
            }
        }
        
        return true
    }
    
    func backtracking(_ r: Int) {
        // 여기까지 왔다면 모든 퀸은 서로 공격할 수 없다.
        if r == n {
            result += 1
            return
        }
        
        for i in 0..<n {
            // r: 행 좌표, i: 열 좌표, r은 재귀하면서 증가함
            // visited[i] = 현재 행 r에서 해당 열 좌표에 대한 탐색이 이루어졌는지를 의미
            if visited[i] {
                continue
            }
            
            // 탐색되지 않았다면 board[r]의 열을 i로 지정 (=> 해당 좌표에 퀸을 놓음)
            board[r] = i
            
            if isSafe(at: r) {
                visited[i] = true
                backtracking(r + 1)
                visited[i] = false
                // 백트래킹을 하므로 모든 행에 대해서 열 탐색 여부를 알 수 있다??
            }
        }
    }
    
    backtracking(0)
    print(result)
}

/*
 [해설]
 하나도 몰라서 여기저기서 베낌
 - 같은 열, 같은 행, 대각선 방향에 있으면 공격당하므로 위치할 수 없다.
 - 놓을 수 있다고 판단하면 다음 재귀함수 호출로 퀸을 더 놓아보기
 
 https://chanhuiseok.github.io/posts/baek-1/
 N-Queen 문제란 크기가 NxN인 체스판 위에 퀸 N개를 서로 공격할 수 없도록 놓는 경우의 수를 구하는 문제입니다.
 여기서 서로 공격할 수 없다는 조건은 다음과 같습니다.
 퀸이 놓였을 때 퀸 자신을 기준으로 일직선상(가로 및 세로)과 대각선 방향에는 아무것도 놓여있으면 안 된다.
 그림으로 살펴보면 다음과 같습니다.
 
 👑🟥🟥🟥
 🟥🟥⬜️⬜️
 🟥⬜️🟥⬜️
 🟥⬜️⬜️🟥
 1. (0, 0)에 퀸을 놓았을 때 그 다음 줄에는 (1, 2) 혹은 (1, 3)에 놓을 수 있다.
 
 👑🟥🟥🟥
 🟥🟥👑🟧
 🟥🟧🟪🟧
 🟥⬜️🟧🟥
 2. (1, 2)에 놓는다면 그 다음 줄에는 아무것도 놓을 수 없으므로 되돌아간다.
 
 👑🟥🟥🟥       👑🟥🟥🟥        🟥👑🟥🟥
 🟥🟥🟥👑       🟥🟥🟥👑        🟥🟥🟥⬜️
 🟥⬜️🟥🟥       🟥👑🟥🟥        ⬜️🟥⬜️🟥
 🟥🟥⬜️🟥       🟥🟥🟧🟥        ⬜️🟥⬜️⬜️
 3. (1, 3)에 놓을 시 다음 줄에 놓을 수 있는 칸이 있으므로 두고 다음으로 가본다.
 4. (2, 1)에 놓을 시 다음 줄에는 더 이상 둘 수 없으므로 실패한다.
 5. 맨 첫번째 행 퀸을 다음 (0, 1)로 옮겨서 같은 과정을 진행한다.
 
 ** 굳이 이차원 배열을 사용할 필요가 없습니다. **
 ◾️0️⃣1️⃣2️⃣3️⃣
 0️⃣⬜️⬜️👑⬜️
 1️⃣👑⬜️⬜️⬜️
 2️⃣⬜️⬜️⬜️👑
 3️⃣⬜️👑⬜️⬜️
 - 배열 Index를 행으로 두고 원소값을 열로 두면 (2, 0, 3, 1)
 - 이 열의 위치를 담는 1차원 배열만 만들어서 사용하면 코딩할 수 있습니다.
 
 ◾️0️⃣1️⃣2️⃣3️⃣
 0️⃣⬜️⬜️👑⬜️
 1️⃣👑⬜️⬜️⬜️
 2️⃣⬜️⬜️👑⬜️
 3️⃣⬜️⬜️⬜️⬜️
 - 1차원 배열에서 값이 하나라도 같은 것이 있게 되면, 열 위치가 같다는 것이므로 (=> 성립할 수 없습니다).
 
 ◾️0️⃣1️⃣2️⃣3️⃣
 0️⃣⬜️⬜️👑⬜️
 1️⃣👑⬜️⬜️⬜️
 2️⃣⬜️👑⬜️⬜️
 3️⃣⬜️⬜️⬜️⬜️
 - 행 번호 차이 = 열 번호 차이면 같은 대각선상에 있는 것
 - (2, 1)의 행 '2' - (1, 0)의 행 '1' = | (2, 1)의 열 '1' - (1, 0)의 열 '0' |
 
 --------------
 
 N-Queen https://www.acmicpc.net/problem/9663
 
 시간 제한    메모리 제한    제출    정답    맞힌 사람    정답 비율
 10 초    128 MB    112358    54007    34960    46.564%
 
 문제
 N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

 N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.

 입력
 첫째 줄에 N이 주어진다. (1 ≤ N < 15)

 출력
 첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.

 예제 입력 1
 8
 
 예제 출력 1
 92
 */
