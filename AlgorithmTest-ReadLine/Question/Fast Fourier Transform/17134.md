
# 🧮 백준 17134번 르모앙의 추측: FFT로 푸는 방식과 시간 초과 해결기

- https://www.acmicpc.net/problem/17134

## 🔍 문제 요약

르모앙의 추측에 따르면,

> **5보다 큰 홀수는 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타낼 수 있다.**

* **홀수 소수**: 3, 5, 7, 11, ...
* **짝수 세미소수**: 두 소수의 곱이면서 짝수인 수 (ex. 2×3 = 6, 2×11 = 22, …)

### 🧩 문제 목표

입력으로 주어진 여러 개의 홀수 $N$에 대해,
**$N = 홀수 소수 + 짝수 세미소수$** 가 되는 조합의 수를 계산해야 합니다.

---

## 🧠 핵심 아이디어: 컨볼루션 + FFT

이 문제는 일종의 "두 수의 합이 N이 되는 쌍을 빠르게 세는 문제"입니다.
이를 위해 다음과 같은 전략을 사용합니다.

### 1. 수열 구성

* `A[x] = 1` if `x`는 **홀수 소수**
* `B[x] = 1` if `x`는 **짝수 세미소수**
  → 배열 A, B를 생성한 뒤 컨볼루션(합성곱)을 통해 결과 계산

### 2. 컨볼루션 수행

$$
C[n] = \sum_{i=0}^{n} A[i] \cdot B[n - i]
$$

즉, `A[i]`와 `B[n - i]`가 모두 1인 경우, `i + (n - i) = n`이 되는 조합의 수를 `C[n]`에 저장하게 됩니다.

---

## ⚙️ 사용된 알고리즘

### ✅ 에라토스테네스의 체

* 소수를 구하기 위한 고전적인 방법
* $O(n \log \log n)$

### ✅ 고속 푸리에 변환 (FFT)

* 컨볼루션을 빠르게 계산하기 위한 수단
* 일반적인 O(n²) 곱셈 → O(n log n)으로 단축 가능

---

## ⏰ 시간 초과 문제 원인과 해결

### 문제 상황

처음에는 `FFT`를 **재귀 함수로 구현**했으나,

* 입력 크기가 최대 1,000,000이고
* FFT 내부에서 수십 번 재귀가 발생하며
* 각 재귀에서 배열 복사 및 분할 처리 발생

→ 결과적으로 **시간 초과**가 발생했습니다.

### 해결 방법

* `FFT`를 **비재귀(iterative) 방식으로 변경**
* `bit reversal`과 `in-place 배열 처리`를 사용해 메모리 복사 최소화
* `Complex` 연산 최적화로 연산 속도 증가

→ 이후 **모든 테스트 케이스가 시간 제한 내 통과**, 정답 처리되었습니다.

---

## ✅ 주요 구현 포인트 요약

| 파트                  | 설명                          |
| ------------------- | --------------------------- |
| `sieve`             | 소수 판별: 홀수 소수 추출용            |
| `isOddPrime`        | 홀수 소수를 1로 마킹한 배열            |
| `isEvenSemiPrime`   | 2×소수 형태의 짝수 세미소수를 1로 마킹한 배열 |
| `convolutionII`     | 비재귀 FFT를 통한 빠른 컨볼루션 수행      |
| `round(conv[n].re)` | 실수 오차 보정 후 정수화              |

---

## 📌 결론

이 문제는 고속 푸리에 변환을 실전 문제에 적용하는 좋은 예시입니다.
또한, \*\*단순히 알고리즘을 사용하는 것뿐 아니라, 구현 방식(재귀 vs 반복)\*\*이 실제 성능에 얼마나 큰 영향을 미치는지를 잘 보여주는 문제이기도 합니다.

---

## 🏁 Tip

* Swift로 FFT를 구현할 땐 재귀보다는 **bit-reversal + iterative FFT**를 추천합니다.
* 실수 오차는 `round()`로 보정하고, 배열 인덱스 접근 시 항상 범위 체크를 습관화하세요.

