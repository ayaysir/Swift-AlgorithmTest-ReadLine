# 🧮 백준 17134번 르모앙의 추측

이 문제를 **고속 푸리에 변환 (FFT)** 으로 푸는 핵심은 다음과 같습니다:

---

## 🎯 문제 요약 다시 한 번

* 홀수 $N$이 주어졌을 때,
* **홀수 소수 $p$** + **짝수 세미소수 $s$** 로 $N = p + s$ 를 만족하는 조합의 수를 세는 것

---

## ✅ 핵심 아이디어

이 문제도 **"두 수의 합 = N"인 경우의 수를 세는 문제**입니다.
→ 이런 유형은 **컨볼루션**으로 빠르게 계산할 수 있습니다.
(두 수열 A, B에 대해 A\[i] \* B\[N - i]의 누적합을 계산하는 구조)

---

## 🧠 FFT로 접근하는 전략 (힌트 순서)

### ① 에라토스테네스의 체로 소수를 구한다 (1 ≤ x ≤ 1,000,000)

* 소수 배열 `isPrime[x] = true/false` 생성

---

### ② 두 수열을 만든다:

* `A[x] = 1` if x is **홀수 소수**
* `B[x] = 1` if x is **짝수 세미소수**

> 세미소수 = 두 소수의 곱
> 짝수 세미소수 = 그 곱이 짝수일 것 → 하나는 반드시 2여야 하므로
> → 대부분 형태는: `2 × p` (홀수 소수)

---

### ③ A와 B를 FFT 컨볼루션

* `C = convolution(A, B)`
* 그러면 `C[N] = A[p] * B[N - p]` 의 총합 =
  **"홀수 소수 + 짝수 세미소수 = N"인 조합의 수**

---

### ④ 여러 테스트 케이스를 빠르게 처리

* 최대 N = 1,000,000이므로
* 미리 컨볼루션 결과 `C`를 계산해놓고
* 테스트 케이스마다 `print(C[N])` 하면 O(1)에 처리 가능

---

## 🚨 주의할 점

| 주의           | 이유                        |
| ------------ | ------------------------- |
| 배열 크기        | 2의 거듭제곱으로 2,097,152 이상 권장 |
| 좌표 shift 불필요 | 모든 값이 양의 정수이므로            |
| 실수 오차        | 컨볼루션 후 `round()` 처리 필수    |

---

## ✅ 요약 전략

| 단계 | 설명                       |
| -- | ------------------------ |
| ①  | 에라토스테네스의 체로 소수 판정        |
| ②  | `A[x] = 1` if x는 홀수 소수   |
|    | `B[x] = 1` if x는 짝수 세미소수 |
| ③  | FFT로 `A * B` 컨볼루션 계산     |
| ④  | 결과 배열에서 `C[N]` 값 출력      |


---

# A[x] = 1의 의미

"**A\[x] = 1**"이 무슨 뜻인지, 왜 그냥 1만 넣으면 되는지 **배열의 의미**부터 **컨볼루션에서의 역할**까지 자세히 설명드릴게요.

---

## ✅ A\[x] = 1 이라는 표현의 의미

이건 다음과 같은 뜻입니다:

> **A라는 배열에서 인덱스 x 위치에 값 1을 넣는다**
> → 즉, **x가 특정한 수라면 (예: 홀수 소수라면)** 그 자리에는 `1`,
> 아니면 `0`을 넣는다는 뜻입니다.

### 예:

```swift
A[3] = 1 // 3은 홀수 소수이므로
A[4] = 0 // 4는 소수가 아니므로
```

이 배열은 일종의 **존재 표시 배열**, 또는 **frequency 배열**이라고도 부릅니다.

---

## ✅ 왜 "1만 넣으면 되나요?"

네! 이유는 이 문제에서 **두 수의 "쌍"을 세기만 하면 되기 때문**입니다.

* 수 $N = p + s$를 만족하는 경우의 수를 세고자 할 때
* 우리는 단순히 어떤 수가 "존재하느냐 / 존재하지 않느냐"만 알면 됩니다.
* 그래서 A\[x]나 B\[x]에 **딱 한 번만 1을 넣으면 충분**합니다.

---

## ✅ 컨볼루션에서의 역할

이제 이 배열들을 FFT에 넣게 되면,

```swift
C = convolution(A, B)
```

이때 C\[n]은 다음을 의미합니다:

> **A\[i] \* B\[n - i]의 누적합**
> → 즉, A에서 i가 1이고, B에서 n - i가 1인 모든 (i, n - i) 쌍의 개수

→ 다시 말하면,
**"홀수 소수 + 짝수 세미소수 = N"이 되는 쌍의 수**

---

## 🧠 예시로 보기

```swift
홀수 소수: [3, 5, 7]
짝수 세미소수: [4, 6, 10]

→ A[3] = 1, A[5] = 1, A[7] = 1
→ B[4] = 1, B[6] = 1, B[10] = 1
```

컨볼루션 결과:

* C\[7] = A\[3]\*B\[4] → 1
* C\[9] = A\[3]\*B\[6] + A\[5]\*B\[4] → 1 + 1 = 2
* C\[13] = A\[3]\*B\[10] + A\[5]\*B\[8] + A\[7]\*B\[6] → 등등…

→ `C[N]` = $N = 소수 + 세미소수$가 되는 방법의 수

---

## ✅ 정리

| 표현        | 의미                    |
| --------- | --------------------- |
| A\[x] = 1 | x가 홀수 소수임을 표시         |
| B\[x] = 1 | x가 짝수 세미소수임을 표시       |
| 값은 왜 1?   | "존재한다"는 정보만 있으면 충분하니까 |
| 컨볼루션 결과   | 두 수의 합이 N이 되는 경우의 수   |

---


# 🧮 백준 17134번 르모앙의 추측: FFT로 푸는 방식과 시간 초과 해결기

- https://www.acmicpc.net/problem/17134

## 🔍 문제 요약

르모앙의 추측에 따르면,

> **5보다 큰 홀수는 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타낼 수 있다.**

* **홀수 소수**: 3, 5, 7, 11, ...
* **짝수 세미소수**: 두 소수의 곱이면서 짝수인 수 (ex. 2×3 = 6, 2×11 = 22, …)

### 🧩 문제 목표

입력으로 주어진 여러 개의 홀수 $N$에 대해,
**$N = 홀수 소수 + 짝수 세미소수$** 가 되는 조합의 수를 계산해야 합니다.

---

## 🧠 핵심 아이디어: 컨볼루션 + FFT

이 문제는 일종의 "두 수의 합이 N이 되는 쌍을 빠르게 세는 문제"입니다.
이를 위해 다음과 같은 전략을 사용합니다.

### 1. 수열 구성

* `A[x] = 1` if `x`는 **홀수 소수**
* `B[x] = 1` if `x`는 **짝수 세미소수**
  → 배열 A, B를 생성한 뒤 컨볼루션(합성곱)을 통해 결과 계산

### 2. 컨볼루션 수행

$$
C[n] = \sum_{i=0}^{n} A[i] \cdot B[n - i]
$$

즉, `A[i]`와 `B[n - i]`가 모두 1인 경우, `i + (n - i) = n`이 되는 조합의 수를 `C[n]`에 저장하게 됩니다.

---

## ⚙️ 사용된 알고리즘

### ✅ 에라토스테네스의 체

* 소수를 구하기 위한 고전적인 방법
* $O(n \log \log n)$

### ✅ 고속 푸리에 변환 (FFT)

* 컨볼루션을 빠르게 계산하기 위한 수단
* 일반적인 O(n²) 곱셈 → O(n log n)으로 단축 가능

---

## ⏰ 시간 초과 문제 원인과 해결

### 문제 상황

처음에는 `FFT`를 **재귀 함수로 구현**했으나,

* 입력 크기가 최대 1,000,000이고
* FFT 내부에서 수십 번 재귀가 발생하며
* 각 재귀에서 배열 복사 및 분할 처리 발생

→ 결과적으로 **시간 초과**가 발생했습니다.

### 해결 방법

* `FFT`를 **비재귀(iterative) 방식으로 변경**
* `bit reversal`과 `in-place 배열 처리`를 사용해 메모리 복사 최소화
* `Complex` 연산 최적화로 연산 속도 증가

→ 이후 **모든 테스트 케이스가 시간 제한 내 통과**, 정답 처리되었습니다.

---

## ✅ 주요 구현 포인트 요약

| 파트                  | 설명                          |
| ------------------- | --------------------------- |
| `sieve`             | 소수 판별: 홀수 소수 추출용            |
| `isOddPrime`        | 홀수 소수를 1로 마킹한 배열            |
| `isEvenSemiPrime`   | 2×소수 형태의 짝수 세미소수를 1로 마킹한 배열 |
| `convolutionII`     | 비재귀 FFT를 통한 빠른 컨볼루션 수행      |
| `round(conv[n].re)` | 실수 오차 보정 후 정수화              |

---

## 📌 결론

이 문제는 고속 푸리에 변환을 실전 문제에 적용하는 좋은 예시입니다.
또한, \*\*단순히 알고리즘을 사용하는 것뿐 아니라, 구현 방식(재귀 vs 반복)\*\*이 실제 성능에 얼마나 큰 영향을 미치는지를 잘 보여주는 문제이기도 합니다.

---

## 🏁 Tip

* Swift로 FFT를 구현할 땐 재귀보다는 **bit-reversal + iterative FFT**를 추천합니다.
* 실수 오차는 `round()`로 보정하고, 배열 인덱스 접근 시 항상 범위 체크를 습관화하세요.

