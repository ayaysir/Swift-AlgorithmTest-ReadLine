//
//  10531.swift
//  AlgorithmTest-ReadLine
//
//  Created by ìœ¤ë²”íƒœ on 5/16/25.
//
// 1: Golf Bot https://www.acmicpc.net/problem/10531
//

/*
 ì´ ë¬¸ì œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì„ ê°€ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤:

 â¸»

 ìƒí™© ìš”ì•½
   â€¢  ë‹¹ì‹ ì€ ê³¨í”„ ë¡œë´‡ì„ ê°€ì§€ê³  ìˆëŠ”ë°, ì´ ë¡œë´‡ì€ íŠ¹ì • ê±°ë¦¬ë“¤ë§Œ ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   â€¢  ë¡œë´‡ì´ ì¹  ìˆ˜ ìˆëŠ” ê±°ë¦¬ë“¤ì€ Nê°œì˜ ì •ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.
 ì˜ˆ: 1, 3, 5 ê°™ì€ ê±°ë¦¬ë§Œ ì¹  ìˆ˜ ìˆë‹¤ë©´, ë¡œë´‡ì€ ë”± ì´ ê±°ë¦¬ë§Œí¼ë§Œ ê³µì„ ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   â€¢  ê³¨í”„ì¥ì˜ ê° í™€ê¹Œì§€ì˜ ê±°ë¦¬ê°€ Mê°œ ì£¼ì–´ì§‘ë‹ˆë‹¤.
   â€¢  ë‹¹ì‹ ì€ ìµœëŒ€ ë‘ ë²ˆê¹Œì§€ ê³µì„ ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‘ ë²ˆì˜ í•©ìœ¼ë¡œ ì •í™•íˆ í™€ì— ë„ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤.
   â€¢  ì˜ˆë¥¼ ë“¤ì–´, í™€ê¹Œì§€ì˜ ê±°ë¦¬ê°€ 4ì´ê³ , ë¡œë´‡ì´ 1, 3, 5 ê±°ë¦¬ë§Œ ì¹  ìˆ˜ ìˆë‹¤ë©´ 1 + 3 = 4ë¡œ ë„ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   â€¢  ë¡œë´‡ì€ ê³ ì˜ë¡œ ì§€ë‚˜ì³¤ë‹¤ê°€ ë’¤ë¡œ ì¹˜ëŠ” í–‰ë™ì€ ëª»í•©ë‹ˆë‹¤. (ì¦‰, ê±°ë¦¬ì˜ í•©ì´ ì •í™•íˆ í™€ê¹Œì§€ì˜ ê±°ë¦¬ì—¬ì•¼ í•¨)

 â¸»

 ëª©í‘œ

 Mê°œì˜ í™€ë“¤ ì¤‘ì—ì„œ, ìµœëŒ€ 2ë²ˆì˜ ìŠ¤íŠ¸ë¡œí¬ë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ í™€ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” ê²ƒì´ ë¬¸ì œì˜ ëª©í‘œì…ë‹ˆë‹¤.

 â¸»

 ì…ë ¥ í˜•ì‹ (ì •ë¦¬)

 N
 
 k1
 k2
 ...kN
 
 M
 
 d1
 d2
 ...dM

   â€¢  ki: ë¡œë´‡ì´ ì¹  ìˆ˜ ìˆëŠ” ê±°ë¦¬ë“¤
   â€¢  dj: ê° í™€ê¹Œì§€ì˜ ê±°ë¦¬

 â¸»

 ì¶œë ¥ í˜•ì‹
   â€¢  í•œ ì¤„ì— 2ë²ˆ ì´ë‚´ì˜ ìŠ¤íŠ¸ë¡œí¬ë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ í™€ì˜ ê°œìˆ˜ ì¶œë ¥

 â¸»

 ì˜ˆì‹œ ì…ë ¥ 1 í•´ì„

 ì…ë ¥:

3
1
3
5
6
2
4
5
7
8
9

   â€¢  ë¡œë´‡ì´ ì¹  ìˆ˜ ìˆëŠ” ê±°ë¦¬: [1, 3, 5]
   â€¢  í™€ì˜ ê±°ë¦¬: [2, 4, 5, 7, 8, 9]

 ë„ë‹¬ ê°€ëŠ¥í•œ í™€ ê³„ì‚°:
   â€¢  2 = 1+1 âœ”ï¸
   â€¢  4 = 1+3 âœ”ï¸
   â€¢  5 = 5 âœ”ï¸
   â€¢  7 = 3+4 âŒ (4ëŠ” ì—†ìŒ)
   â€¢  8 = 3+5 âœ”ï¸
   â€¢  9 = 5+4 âŒ (4ëŠ” ì—†ìŒ)

 => ì •ë‹µ: 4

 â¸»

 í•µì‹¬ í¬ì¸íŠ¸
   â€¢  **ê°€ëŠ¥í•œ ëª¨ë“  1íšŒ ê±°ë¦¬ë“¤ (k)**ì„ ì €ì¥
   â€¢  **ê°€ëŠ¥í•œ ëª¨ë“  2íšŒ ê±°ë¦¬ë“¤ (k1 + k2)**ë¥¼ ë§Œë“¤ì–´ ì €ì¥
   â€¢  ê° djì— ëŒ€í•´, djê°€ 1íšŒ ê±°ë¦¬ ë˜ëŠ” 2íšŒ ê±°ë¦¬ ì§‘í•©ì— ìˆëŠ”ì§€ í™•ì¸

 â¸»
 */

func Q_10531() {
  let N = Int(readLine()!)!
  let ks = (0..<N).map { _ in Int(readLine()!)! }
  let M = Int(readLine()!)!
  let ds = (0..<M).map { _ in Int(readLine()!)! }
  
  // ë¡œë´‡ì´ í•œ ë²ˆì— ì¹  ìˆ˜ ìˆëŠ” ê±°ë¦¬: ìµœëŒ€ 200,000
  let maxDistance = 200_000
  var freq = [Int](repeating: 0, count: maxDistance + 1)

  for k in ks {
    freq[k] = 1
  }
  
  /*
   âœ… ì‚¬ìš© ëª©ì  (10531 ë¬¸ì œì—ì„ ?)
   ë¡œë´‡ì´ ì¹  ìˆ˜ ìˆëŠ” ê±°ë¦¬ë“¤ì´ [1, 3, 5]ë¼ê³  í•˜ë©´
   - freq[k] = 1ì¸ ë°°ì—´ freqë¥¼ ë‘ ë²ˆ ê³±í•˜ë©´,
   - ê±°ë¦¬ k1 + k2ë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ ëª¨ë“  ê±°ë¦¬ë“¤ì´ ì»¨ë³¼ë£¨ì…˜ ê²°ê³¼ë¡œ ë‚˜ì˜µë‹ˆë‹¤
   - ì´ë•Œ conv[d] > 0ì´ë©´, ê±°ë¦¬ dëŠ” 2ë²ˆì— ë„ë‹¬ ê°€ëŠ¥í•˜ë‹¤ëŠ” ëœ»
   */
  let conv = convolution(freq, freq)
  
  var reachable = [Bool](repeating: false, count: conv.count)
  for i in 0..<freq.count where freq[i] == 1 {
    reachable[i] = true // 1-shot
  }
  
  for i in 0..<freq.count where conv[i] > 0 {
    reachable[i] = true // 2-shot
  }
  
  var result = 0
  for d in ds where d < reachable.count && reachable[d] {
    result += 1
  }
  
  print(result)
}

import Foundation

/// `Complex` êµ¬ì¡°ì²´ëŠ” **ë³µì†Œìˆ˜(Complex Number)**ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•œ ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì…ë‹ˆë‹¤. Swift 5.5ì—ëŠ” ë³µì†Œìˆ˜ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì§€ì›í•˜ëŠ” íƒ€ì…ì´ ì—†ê¸° ë•Œë¬¸ì—, ì§ì ‘ êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤.
/// - Parameters:
///   - re: ì‹¤ìˆ˜(real) ë¶€ë¶„
///   - im: í—ˆìˆ˜(imaginary) ë¶€ë¶„
struct Complex {
  var re: Double
  var im: Double

  init(_ re: Double, _ im: Double) {
    self.re = re
    self.im = im
  }

  static func + (a: Complex, b: Complex) -> Complex {
    return Complex(a.re + b.re, a.im + b.im)
  }

  static func - (a: Complex, b: Complex) -> Complex {
    return Complex(a.re - b.re, a.im - b.im)
  }

  static func * (a: Complex, b: Complex) -> Complex {
    return Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
  }

  static func / (a: Complex, b: Double) -> Complex {
    return Complex(a.re / b, a.im / b)
  }
  
  /// ë³µí•© ì—°ì‚°ì (ê³±ì…ˆ)
  static func *= (a: inout Complex, b: Complex) {
    a = a * b
  }
  
  /// ë³µí•© ì—°ì‚°ì (ë‚˜ëˆ—ì…ˆ)
  static func /= (a: inout Complex, b: Double) {
    a = a / b
  }
}

/// fftëŠ” **Fast Fourier Transform(ê³ ì† í‘¸ë¦¬ì— ë³€í™˜)**ì˜ ì•½ìë¡œ, ì…ë ¥ ë°°ì—´ì„ ì‹œê°„ ì˜ì—­ â†’ ì£¼íŒŒìˆ˜ ì˜ì—­ìœ¼ë¡œ ë°”ê¾¸ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
/// - ì™œ ì“°ëŠ”ê°€?
///   - ì»¨ë³¼ë£¨ì…˜ì„ ë¹ ë¥´ê²Œ ê³„ì‚°í•˜ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤.
///   - ì¼ë°˜ì ìœ¼ë¡œ ì»¨ë³¼ë£¨ì…˜ì€ O(NÂ²)ì´ì§€ë§Œ, FFTë¥¼ ì‚¬ìš©í•˜ë©´ **O(N log N)**ìœ¼ë¡œ ê³„ì‚° ê°€ëŠ¥
/// - Parameters:
///   - a: ë³µì†Œìˆ˜ ë°°ì—´ (ì…ë ¥ + ê²°ê³¼ê°€ ì´ ì•ˆì—ì„œ ì²˜ë¦¬ë¨)
///   - invert: `false`ëŠ” ì •ë°©í–¥ FFT, trueëŠ” ì—­ë°©í–¥ FFT(iFFT)
/// - âœ… í•µì‹¬ ê°œë… ìš”ì•½
///   | ë‹¨ê³„     | ì„¤ëª…                                   |
///   | ------ | ------------------------------------ |
///   | ë¶„í•      | ì§ìˆ˜/í™€ìˆ˜ ì¸ë±ìŠ¤ë¡œ ë‚˜ëˆ”                        |
///   | ì •ë³µ     | ë‚˜ëˆˆ ë°°ì—´ì„ ì¬ê·€ì ìœ¼ë¡œ ë‹¤ì‹œ FFT ì ìš©               |
///   | ë³‘í•©     | ê²°ê³¼ë¥¼ ë³µì†Œìˆ˜ ê³±ê³¼ í•©ìœ¼ë¡œ í•©ì¹¨ (`u + v`, `u - v`) |
///   | íšŒì „ ì¸ì  | ê° ë‹¨ê³„ì—ì„œ ë³µì†Œìˆ˜ ì›ì— ë”°ë¼ íšŒì „í•˜ëŠ” `w`ì™€ `wn`      |
///   | ì—­ë³€í™˜ ë³´ì • | `invert == true`ì¼ ê²½ìš° ê²°ê³¼ë¥¼ 2ë¡œ ë‚˜ëˆ ì„œ ë³µì›   |

func fft(_ a: inout [Complex], invert: Bool) {
  let n = a.count
  if n == 1 { return }
  
  var a0 = [Complex]()
  var a1 = [Complex]()
  a0.reserveCapacity(n / 2)
  a1.reserveCapacity(n / 2)
  
  // ì§ìˆ˜ ì¸ë±ìŠ¤ì™€ í™€ìˆ˜ ì¸ë±ìŠ¤ë¡œ ë‚˜ëˆ”
  // Cooley-Tukey FFT Algorithm
  for i in 0..<n {
    if i % 2 == 0 {
      a0.append(a[i])
    } else {
      a1.append(a[i])
    }
  }
  
  // ë‚˜ëˆˆ ë°°ì—´ì„ ê°ê° FFT ì¬ê·€ ì²˜ë¦¬ (Divide and Conquer)
  fft(&a0, invert: invert)
  fft(&a1, invert: invert)
  
  // ë‚˜ëˆ ì§„ ê²°ê³¼ í•©ì¹˜ê¸°
  // íšŒì „ ì¸ì ê³„ì‚°
  let ang = 2.0 * Double.pi / Double(n) * (invert ? -1 : 1)
  var w = Complex(1, 0)
  // wn: í˜„ì¬ ë‹¨ê³„ì—ì„œ ë³µì†Œìˆ˜ ì›ì„ ë”°ë¼ ê³±í•´ì¤„ ê¸°ë³¸ ë‹¨ìœ„
  let wn = Complex(cos(ang), sin(ang))
  
  for i in 0..<n/2 {
    let u = a0[i]
    let v = a1[i] * w
    a[i] = u + v
    a[i + n/2] = u - v
    w *= wn // ë³µì†Œìˆ˜ ì›ìƒì˜ íšŒì „ì„ ì ìš©(ì¦‰, ì£¼íŒŒìˆ˜ ê°ë„ ì¦ê°€)
  }
  
  // ì—­ë³€í™˜ì¼ ê²½ìš° ìŠ¤ì¼€ì¼ ì¡°ì •
  if invert {
    for i in 0..<n {
      a[i] /= 2.0
    }
  }
}

/**
 ì»¨ë³¼ë£¨ì…˜: ë‘ ë°°ì—´ì˜ ê³±ì…ˆ í•©ì„ í†µí•´ ìƒˆë¡œìš´ ë°°ì—´ì„ ë§Œë“œëŠ” ì—°ì‚°
 ---

 ## âœ… ì§ê´€ì  ì •ì˜

 ë‘ ë°°ì—´ `A`ì™€ `B`ê°€ ìˆì„ ë•Œ, ì»¨ë³¼ë£¨ì…˜ `C`ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë©ë‹ˆë‹¤:

 $$
 C[k] = \sum_{i=0}^{k} A[i] \cdot B[k - i]
 $$

 ì¦‰, ì¸ë±ìŠ¤ê°€ `k`ì¸ ì§€ì ì—ì„œ `A`ì˜ ì•ë¶€ë¶„ê³¼ `B`ì˜ ë’·ë¶€ë¶„ì„ ê³±í•˜ê³  ë”í•œ ê²ƒì…ë‹ˆë‹¤.
 ì´ ì—°ì‚°ì€ ê° `k`ì— ëŒ€í•´ **ëª¨ë“  ê°€ëŠ¥í•œ ìŒì˜ ê³±**ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

 ---

 ## ğŸ”§ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°

 ```swift
 let A = [1, 2, 3]
 let B = [4, 5, 6]
 ```

 ì»¨ë³¼ë£¨ì…˜ ê²°ê³¼ CëŠ” ê¸¸ì´ê°€ `A.count + B.count - 1 = 5`ì¸ ë°°ì—´ì´ ë©ë‹ˆë‹¤.

 ê° í•­ì„ ê³„ì‚°í•˜ë©´:

 * `C[0] = A[0]*B[0] = 1*4 = 4`
 * `C[1] = A[0]*B[1] + A[1]*B[0] = 1*5 + 2*4 = 5 + 8 = 13`
 * `C[2] = A[0]*B[2] + A[1]*B[1] + A[2]*B[0] = 1*6 + 2*5 + 3*4 = 6 + 10 + 12 = 28`
 * `C[3] = A[1]*B[2] + A[2]*B[1] = 2*6 + 3*5 = 12 + 15 = 27`
 * `C[4] = A[2]*B[2] = 3*6 = 18`

 ê²°ê³¼:

 ```swift
 C = [4, 13, 28, 27, 18]
 ```

 ---

 ## ğŸ§  ì™œ ì¤‘ìš”í•œê°€?

 ì»¨ë³¼ë£¨ì…˜ì€:

 * **ë‘ ìˆ˜ì˜ í•©ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ ê³„ì‚°**
 * **ì´ë¯¸ì§€ í•„í„°ë§ (ë¸”ëŸ¬, ì—£ì§€ ê°ì§€ ë“±)**
 * **ë””ì§€í„¸ ì‹ í˜¸ ì²˜ë¦¬**
 * **ìŒí–¥ í•©ì„±, ë¦¬ë²„ë¸Œ ì²˜ë¦¬**

 ë“± ìˆ˜ë§ì€ ë¶„ì•¼ì—ì„œ í•µì‹¬ì…ë‹ˆë‹¤.

 ---

 ## ğŸš€ ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ ì»¨ë³¼ë£¨ì…˜

 * ì¼ë°˜ì ì¸ ì»¨ë³¼ë£¨ì…˜ì€ `O(NÂ²)`ì´ì§€ë§Œ,
 * \*\*FFT (ê³ ì† í‘¸ë¦¬ì— ë³€í™˜)\*\*ë¥¼ ì´ìš©í•˜ë©´ `O(N log N)`ìœ¼ë¡œ ë¹ ë¥´ê²Œ ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * ë¬¸ì œ í’€ì´ ì‚¬ì´íŠ¸ì—ì„œ **"ë‘ ìˆ˜ì˜ í•©ìœ¼ë¡œ ê°€ëŠ¥í•œ ê±°ë¦¬ ê³„ì‚°"** ë“±ì— ìì£¼ í™œìš©ë©ë‹ˆë‹¤.
 
 ---
 ## ìš”ì•½

 | ë‹¨ê³„ | ì„¤ëª…                        |
 | -- | ------------------------- |
 | 1. | ì…ë ¥ ë°°ì—´ì„ 2ì˜ ê±°ë“­ì œê³± ê¸¸ì´ë¡œ í™•ì¥     |
 | 2. | ë³µì†Œìˆ˜ ë°°ì—´ë¡œ ë³€í™˜                |
 | 3. | FFTë¥¼ ì´ìš©í•´ ì£¼íŒŒìˆ˜ ë³€í™˜           |
 | 4. | ì£¼íŒŒìˆ˜ ì˜ì—­ì—ì„œ ê³±ì…ˆ ìˆ˜í–‰ (ì»¨ë³¼ë£¨ì…˜ì˜ í•µì‹¬) |
 | 5. | ì—­ FFTë¡œ ê²°ê³¼ ë³µì›              |
 | 6. | ì‹¤ìˆ˜ë¶€ë§Œ ì¶”ì¶œí•´ ì •ìˆ˜ ë°°ì—´ë¡œ ë°˜í™˜        |

 ---
 - Parameters:
   - a: ì •ìˆ˜ ë°°ì—´ 1
   - b: ì •ìˆ˜ ë°°ì—´ 2

 */
func convolution(_ a: [Int], _ b: [Int]) -> [Int] {
  // ë°°ì—´ í¬ê¸° ì„¤ì • (ë‹¤ìŒ 2ì˜ ê±°ë“­ì œê³±ìœ¼ë¡œ í™•ì¥)
  var n = 1
  while n < a.count + b.count {
    // nì„ 1ë²ˆ ë¹„íŠ¸ ì™¼ìª½ìœ¼ë¡œ ì‹œí”„íŠ¸ í›„ ë³µí•© ëŒ€ì…
    n <<= 1
  }
  /*
   FTëŠ” ë°°ì—´ ê¸¸ì´ê°€ 2ì˜ ê±°ë“­ì œê³±ì´ì–´ì•¼ ë¹ ë¥´ê²Œ ê³„ì‚°í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—
   ì˜ˆ: a.count + b.count = 6ì´ë©´, n = 8ë¡œ ì„¤ì •
   ë‚˜ì¤‘ì— ì‚¬ìš©í•  Complex ë°°ì—´ë“¤ì˜ ê¸¸ì´ë¥¼ ì´ nìœ¼ë¡œ ë§ì¶¥ë‹ˆë‹¤.
   */
  
  // ë³µì†Œìˆ˜ ë°°ì—´ ì¤€ë¹„ (FFT ì—°ì‚°ì€ ì‹¤ìˆ˜ ë° í—ˆìˆ˜ê¹Œì§€ ê³„ì‚°)
  var fa = [Complex](repeating: Complex(0, 0), count: n)
  var fb = [Complex](repeating: Complex(0, 0), count: n)
  
  // ë³µì†Œìˆ˜ ë°°ì—´ë¡œ ë³€í™˜
  for i in 0..<a.count {
    fa[i] = Complex(Double(a[i]), 0)
  }
  for i in 0..<b.count {
    fb[i] = Complex(Double(b[i]), 0)
  }
  
  // ì •ë°©í–¥ FFT ì‹¤í–‰
  fft(&fa, invert: false)
  fft(&fb, invert: false)
  /*
   ì‹œê°„ ì˜ì—­(Time domain)ì˜ ë°ì´í„°ë¥¼ **ì£¼íŒŒìˆ˜ ì˜ì—­(Frequency domain)**ìœ¼ë¡œ ë³€í™˜
   FFTëŠ” ê³±ì…ˆì´ ë¹ ë¥´ë‹¤ëŠ” íŠ¹ì§•ì„ í™œìš©í•˜ê¸° ìœ„í•¨
   */
  
  //ì£¼íŒŒìˆ˜ ì˜ì—­ì—ì„œ ìš”ì†Œë³„ ê³±
  for i in 0..<n {
    fa[i] *= fb[i]
  }
  /*
   - ê°ê°ì˜ ì£¼íŒŒìˆ˜ ì„±ë¶„ì„ ì›ì†Œë³„ë¡œ ê³±í•©ë‹ˆë‹¤
   - ì´ ê³¼ì •ì´ ì»¨ë³¼ë£¨ì…˜ì˜ í•µì‹¬ ì—°ì‚°ì— í•´ë‹¹í•©ë‹ˆë‹¤.
   - ì‹œê°„ ì˜ì—­ì—ì„œì˜ ì»¨ë³¼ë£¨ì…˜ì€ ì£¼íŒŒìˆ˜ ì˜ì—­ì—ì„œì˜ ê³±ì…ˆê³¼ ë™ì¼í•©ë‹ˆë‹¤ (ì»¨ë³¼ë£¨ì…˜ ì •ë¦¬)
   */
  
  // ì—­ FFT ì‹¤í–‰ (ì£¼íŒŒìˆ˜ â†’ ì‹œê°„)
  fft(&fa, invert: true)
  /*
   - ë‹¤ì‹œ ì£¼íŒŒìˆ˜ ì˜ì—­ì„ ì‹œê°„ ì˜ì—­ìœ¼ë¡œ ë³€í™˜
   - ê²°ê³¼ ë°°ì—´ faì— ì»¨ë³¼ë£¨ì…˜ ê²°ê³¼ê°€ ë“¤ì–´ ìˆìŒ
   */
  
  // ê²°ê³¼ ë³µì› (ë°˜ì˜¬ë¦¼í•˜ì—¬ ì •ìˆ˜ ë°°ì—´ë¡œ)
  var result = [Int](repeating: 0, count: n)
  for i in 0..<n {
    result[i] = Int(round(fa[i].re)) // ë³µì†Œìˆ˜ ì‹¤ìˆ˜ë¶€ .reë§Œ ì‚¬ìš© (í—ˆìˆ˜ë¶€ëŠ” 0ì— ìˆ˜ë ´)
  }
  return result
}
