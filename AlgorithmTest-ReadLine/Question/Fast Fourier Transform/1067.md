# 백준 1067: 이동

이 문제는 얼핏 보면 순차적으로 모든 순환 이동 경우를 하나하나 확인하면서 점수를 계산해야 할 것처럼 보이지만, **시간 제한 1초에 N ≤ 60,000**이라면 단순 O(N²)으로는 절대 해결 불가능합니다.

그래서 \*\*고속 푸리에 변환(FFT)\*\*으로 해결하는 것이 포인트입니다.

---
## 문제 요약

 * N개의 수가 있는 X와 Y가 있다. 이때 X나 Y를 순환 이동시킬 수 있다. 순환 이동이란 예를 들어, {1, 2, 3}을 순환 이동시키면 {3, 1, 2}가 될 것이고, {3, 1, 2}는 {2, 3, 1}이 된다. 순환 이동은 0번 또는 그 이상 할 수 있다. 이 모든 순환 이동을 한 후에 점수 S를 구하면 된다.
 * S = X[0]×Y[0] + X[1]×Y[1] + ... + X[N-1]×Y[N-1]
 * 입력: N, Xs, Ys; N은 60,000보다 작거나 같은 자연수이고, X와 Y에 들어있는 모든 수는 100보다 작은 자연수 또는 0이다.
 * 출력: S의 최댓값

이때 S를 최대로 하면 된다.
---

## 🎯 문제의 수학적 핵심

### 점수 S는 사실상 \*\*내적(dot product)\*\*입니다.

$$
S_k = X \cdot \text{rotate}(Y, k)
$$

즉, `Y`를 오른쪽으로 `k`만큼 순환시켜서 `X`와 곱한 내적을 구하는 것.

이 말은 곧, **X와 Y의 모든 순환 시프트에 대한 내적 최대값을 구하는 것**입니다.

### ✅ 내적(Dot Product)이란?

**두 벡터가 얼마나 "같은 방향"을 향하고 있는지를 나타내는 값**이에요.
**수학적으로는**, 두 벡터의 같은 위치 원소끼리 곱해서 다 더한 값입니다.

#### 📌 정의 (1차원 배열 기준):

$$
A \cdot B = A[0] \times B[0] + A[1] \times B[1] + \cdots + A[N-1] \times B[N-1]
$$

#### 🔢 예시

```swift
A = [1, 2, 3]
B = [4, 5, 6]
```

이 둘의 내적은:

$$
1×4 + 2×5 + 3×6 = 4 + 10 + 18 = 32
$$


#### 🧠 내적이 의미하는 것

* 내적이 **클수록 두 벡터는 방향이 비슷**하다는 의미
* **작거나 음수**일 경우 방향이 다르거나 반대라는 뜻

이걸 활용하면,
두 벡터 중 하나를 회전시켜가며 내적을 계산할 때 **가장 큰 내적 값**은 **가장 잘 정렬된 경우**라는 뜻이 됩니다.

#### ⛳ 이 문제에서의 내적

문제에서 점수 S는:

$$
S = X[0] \times Y[0] + X[1] \times Y[1] + \cdots + X[N-1] \times Y[N-1]
$$

→ 즉, **X와 Y의 내적**이에요.

그리고 **Y를 회전 이동시키면서 여러 경우의 내적 중 최대값을 구하라**는 게 이 문제의 본질입니다.

#### ✅ 요약

| 개념     | 설명                      |
| ------ | ----------------------- |
| 내적     | 같은 위치끼리 곱하고 더한 값        |
| 수식     | $\sum A[i] \times B[i]$ |
| 이 문제에선 | X와 Y의 내적 (Y는 회전 가능)     |
| 최대화 목적 | 어떤 회전 상태에서 내적이 가장 큰지 찾기 |

내적은 선형대수와 물리에서도 중요한 개념입니다.


---

## 🧠 힌트: 순환 이동을 푸리에 변환으로 바꾸는 발상

이 문제는 **이산 순환 상관(Circular Cross Correlation)** 문제입니다.
→ 이는 **FFT를 사용한 컨볼루션으로 계산할 수 있습니다**.

---

## 🔑 구체적인 접근 힌트

1. **X는 그대로 사용**한다.
   (이 배열은 기준이고, 안 움직이니까)

2. **Y는 뒤집어서 2배 길이로 붙인다.**

   * `Y_reversed = reversed(Y)`
   * `Y_ext = Y_reversed + Y_reversed`

3. **이제 X와 Y\_ext의 컨볼루션을 수행한다.**

   * 이건 FFT 기반 컨볼루션 (길이는 충분히 2의 제곱수로 맞춰야 함)
   * 결과 배열에서 인덱스 `N-1`부터 `2N-2`까지의 값이
     `X`와 `Y`의 순환 시프트들에 대한 내적 점수이다.

4. 이 중에서 **가장 큰 값을 출력하면 그것이 최대 점수**이다.

---

## 🌀 시각적 예시

예를 들어 `X = [1, 2, 3]`, `Y = [4, 5, 6]`이라면:

* `Y`를 뒤집으면 `[6, 5, 4]`
* 컨볼루션 결과의 특정 구간이 `X`와 `Y`를 각각 0\~N-1만큼 시프트한 내적 결과가 됨

---

## ⚠️ 주의할 점

* FFT 컨볼루션을 위해 **입력 배열의 길이는 최소 `2N` 이상**이어야 하며, **2의 거듭제곱으로 패딩**해줘야 함
* 실수 오차에 대비해 `round()` 처리 필요

---

## ✅ 핵심 개념 요약

| 개념    | 설명                                          |
| ----- | ------------------------------------------- |
| 점수 계산 | 내적 계산                                       |
| 순환 이동 | circular shift = circular cross correlation |
| 해결 전략 | X와 reverse(Y)로 컨볼루션                         |
| 계산 방식 | FFT 기반 컨볼루션으로 내적 점수 구간 추출 후 최댓값 반환          |

---

# 이산 순환 상관

이 문제의 핵심 알고리즘인 \*\*이산 순환 상관 (Discrete Circular Cross-Correlation)\*\*에 대해 직관적으로 설명드릴게요.

---

## ✅ 상관(Correlation)이란?

두 개의 신호(또는 수열)가 **얼마나 비슷한지, 얼마나 잘 맞는지를 측정하는 것**입니다.

> 쉽게 말해: "A 수열과 B 수열을 겹쳐서 곱해 봤을 때 얼마나 잘 맞냐?"

---

## 📏 일반 상관 (Linear Cross-Correlation)

수열 A와 B가 있을 때,
B를 **한 칸씩 밀어가며** A와 내적을 계산합니다.

* 밀면서 A와 B의 일치도를 확인
* 일종의 "패턴 매칭"

### 일반 상관 예제

| 시프트(k) | A 인덱스      | B 인덱스        | 곱셈 내용           | 합계               |
| ------ | ---------- | ------------ | --------------- | ---------------- |
| -2     | \[1, 2, 3] | \[6, \_, \_] | 3×6             | 18               |
| -1     | \[1, 2, 3] | \[5, 6, \_]  | 2×5 + 3×6       | 10 + 18 = 28     |
| 0      | \[1, 2, 3] | \[4, 5, 6]   | 1×4 + 2×5 + 3×6 | 4 + 10 + 18 = 32 |
| 1      | \[1, 2, 3] | \[\_, 4, 5]  | 1×5 + 2×4       | 5 + 8 = 13       |
| 2      | \[1, 2, 3] | \[\_, \_, 4] | 1×4             | 4                |


---

## 🔁 순환 상관 (Circular Cross-Correlation)

**B를 밀어서 끝까지 가면 다시 처음으로 되돌려서 계속 겹칩니다.**

즉, **B를 순환 이동시키며 A와 내적**을 계산합니다.

이게 바로 **이산 순환 상관**입니다.

---

### 📌 수식적으로 표현하면:

$$
(A \circledast B)[k] = \sum_{i=0}^{N-1} A[i] \cdot B[(i + k) \mod N]
$$

* $k$: B를 몇 칸 회전했는지
* `mod N`: 끝을 넘어가면 다시 처음으로 되돌림 (순환)

---

### 🔢 예시

```swift
A = [1, 2, 3]
B = [4, 5, 6]
```

B를 한 칸씩 순환 이동시키며 A와 내적을 계산해봅시다:

| B 위치       | 내적 계산                              | 결과 |
| ---------- | ---------------------------------- | -- |
| \[4, 5, 6] | 1×4 + 2×5 + 3×6 = 32               | 32 |
| \[6, 4, 5] | 1×6 + 2×4 + 3×5 = 6 + 8 + 15 = 29  | 29 |
| \[5, 6, 4] | 1×5 + 2×6 + 3×4 = 5 + 12 + 12 = 29 | 29 |

이렇게 계산된 세 개의 값이 바로 **이산 순환 상관 결과**입니다.

---

## ⚙️ 왜 FFT가 필요한가?

이산 순환 상관은 직접 계산하면 \*\*O(N²)\*\*입니다.
→ 시간 초과 발생

하지만!

> 이산 순환 상관은 FFT를 활용하면 \*\*O(N log N)\*\*에 계산할 수 있습니다.

### 핵심 공식:

$$
A \circledast B = \text{IFFT}( \text{FFT}(A) \cdot \overline{\text{FFT}(B)} )
$$

* FFT로 각각 변환하고
* 하나는 복소수 켤레(conjugate) 취하고
* 곱하고
* 역 FFT로 되돌리면
  → 순환 상관이 나옵니다!

---

## 🧠 이 문제에서 적용

* `X`는 고정
* `Y`를 **순환 이동**하면서 최대 점수를 구하라 → 순환 상관
* FFT 기반 컨볼루션을 쓰면 빠르게 계산 가능

---

## ✅ 요약

| 개념     | 설명                                                          |
| ------ | ----------------------------------------------------------- |
| 순환 상관  | 두 수열의 순환 시프트 간 유사도 계산                                       |
| 수식     | $(A \circledast B)[k] = \sum A[i] \cdot B[(i + k) \mod N])$ |
| 특징     | 회전하면서 내적 계산                                                 |
| 시간 복잡도 | 직접 계산: O(N²), FFT 사용 시: O(N log N)                          |
| 이 문제에서 | X와 순환 이동된 Y의 내적 중 최댓값 계산에 사용                                |

---

# 입력 배열의 길이가 2N 이상이어야 하는 이유?

## ✅ 먼저: 왜 "2N 이상"이어야 할까?

우리가 컨볼루션(합성곱)을 할 때, 두 배열 `A`와 `B`의 길이가 각각 `N`이라고 합시다.

### 일반 컨볼루션 결과 길이는?

$$
\text{len}(A * B) = 2N - 1
$$

왜냐하면 두 배열의 모든 원소가 겹쳐지는 경우를 고려하면,
최대 위치 이동량은 `N - 1`칸이기 때문에
→ 총 `2N - 1`개의 결과값이 나옵니다.

### 📌 그래서 배열을 FFT에 넣기 전에 길이를 최소 **2N**으로 맞춰야

* 곱한 뒤 역 FFT 결과를 **온전히 담을 수 있습니다**
* 만약 더 짧게 하면 **곱셈 결과가 잘립니다.**

---

## ✅ 다음: 왜 "2의 거듭제곱"으로 패딩해야 할까?

FFT의 알고리즘은 **Cooley–Tukey 분할 정복 방식**을 따릅니다.
이 방식은 배열을 **반으로 나누고 또 나누고…** 반복해서 계산합니다.

### ⚠️ 그런데 배열 길이가 2의 거듭제곱이 아니면?

* 정확히 반으로 쪼갤 수 없어서 알고리즘이 깨집니다.
* 성능도 느려지고, 구현도 복잡해집니다.

### 📌 그래서 FFT 라이브러리나 구현은 대부분

* **길이가 2, 4, 8, 16, ..., 2ⁿ**이 아니면
* **오류가 나거나, 내부에서 강제로 패딩해버립니다.**

---

## 🎯 정리

| 이유          | 설명                                        |
| ----------- | ----------------------------------------- |
| **2N 이상**   | 컨볼루션 결과가 최대 `2N - 1` 길이이므로 결과값이 다 담기게 하려면 |
| **2의 거듭제곱** | FFT 알고리즘이 배열을 계속 반으로 나누기 위해 구조적으로 필요      |

---

## 🧠 실제 예시

```swift
let A = [1, 2, 3]
let B = [4, 5, 6]
```

* `A.count = 3`, `B.count = 3`
  → `A * B`의 결과는 길이 `2 * 3 - 1 = 5`

* FFT를 적용할 때는 **최소 5칸 이상 필요**
  → 가장 가까운 2의 거듭제곱은 `8`
  → 그래서 배열을 길이 8로 패딩합니다.

---

# Y를 뒤집는 이유

> **"Y는 뒤집어서 2배 길이로 붙인다."**

는 \*\*이산 순환 상관 (circular cross-correlation)\*\*을 **일반 컨볼루션**으로 계산하기 위한 **기술적인 트릭**입니다.

아래에서 그 이유를 **시각적, 수학적, 알고리즘적** 관점에서 쉽게 설명드릴게요.

---

## ✅ 문제 배경 다시 보기

우리는 다음을 계산하고 싶습니다:

$$
S_k = X[0] \cdot Y[k] + X[1] \cdot Y[k+1 \mod N] + \dots + X[N-1] \cdot Y[k+N-1 \mod N]
$$

즉, **Y를 순환 이동**(rotate)하면서 X와 내적을 수행하는 거죠.
→ 이것이 바로 \*\*순환 상관(Circular Cross-Correlation)\*\*입니다.

---

## ❗ 그런데 FFT로 바로 순환 상관을 계산할 수 있을까?

FFT는 기본적으로 \*\*선형 컨볼루션(linear convolution)\*\*을 계산합니다.

$$
Z[i] = \sum_{j=0}^{i} A[j] \cdot B[i - j]
$$

→ 이건 순환이 아니라, 그냥 밀면서 곱하는 방식

따라서 **순환 상관을 FFT로 처리하려면 별도 트릭이 필요**합니다.

---

## 🎯 해결 방법: Y를 뒤집고 2배로 붙인다

### 1. 왜 뒤집나?

컨볼루션을 곱셈 기반 상관(cross-correlation)으로 바꾸려면 **B를 뒤집어야** 합니다.

* **컨볼루션**: $A * B$
* **상관**: $A * \text{reverse}(B)$

이건 수학적으로도 알려진 관계입니다.
즉, cross-correlation = convolution with reversed B

---

### 2. 왜 2배로 붙이나?

컨볼루션은 선형 계산입니다.
**끝을 넘어가면 그냥 끝입니다. 순환되지 않아요.**

하지만 우리는 **Y가 순환된 상태에서의 모든 내적**을 알고 싶어요.
그래서:

* Y를 뒤집고
* 그것을 자기 자신과 이어붙이면

$$
Y' = \text{reversed}(Y) + \text{reversed}(Y)
$$

이 Y′와 X를 선형 컨볼루션하면,
→ 그 결과의 한 구간(정확히는 `N-1` \~ `2N-2`)이
→ **순환 상관 결과**가 됩니다!

---

## 📐 그림으로 보면

* `X = [a, b, c]`
* `Y = [x, y, z]`
* 뒤집고 2배: `revY = [z, y, x, z, y, x]`
* `conv(X, revY)`를 계산
* 결과 길이 3 + 6 - 1 = 8
* 결과의 인덱스 2, 3, 4가 바로 순환 이동된 Y와 X의 내적 결과

---

## ✅ 정리

| 조작                     | 이유                               |
| ---------------------- | -------------------------------- |
| **뒤집기**                | 컨볼루션을 cross-correlation으로 바꾸기 위해 |
| **2배로 붙이기**            | 순환 효과를 선형 컨볼루션에서 흉내내기 위해         |
| **슬라이싱 (N-1 \~ 2N-2)** | 필요한 순환 내적 결과만 뽑기 위해              |

---

## 🔁 핵심 문장 다시 보기

> **"Y는 뒤집어서 2배 길이로 붙인다."**
> → 그 이유는 **선형 컨볼루션을 이용해서 순환 상관을 흉내 내기 위해서**입니다.

이 트릭 덕분에, **복잡한 순환 연산도 FFT 한 번으로 해결**할 수 있게 됩니다.




