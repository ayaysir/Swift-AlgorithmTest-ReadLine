
# 🏌️‍♂️ 백준 10531번 - Golf Bot: FFT로 푸는 이유와 원리

## 🔍 문제 개요

골프를 싫어하게 된 한 개발자가 로봇을 만들어서 골프를 자동화하려고 합니다.
이 로봇은 딱 정해진 거리들만 칠 수 있습니다. 예를 들어 1m, 3m, 5m 거리만 가능하다면, 로봇은 그 외 거리(예: 2m)는 한 번에 칠 수 없습니다.

**목표는?**
여러 개의 홀까지 거리가 주어질 때, 로봇이 **최대 2번의 샷으로** 공을 홀에 넣을 수 있는 경우가 몇 개인지를 세는 것입니다.

---

## ⛳ 입력 예시

```
3
1
3
5
6
2
4
5
7
8
9
```

* 로봇이 칠 수 있는 거리: 1, 3, 5
* 각 홀까지의 거리: 2, 4, 5, 7, 8, 9

---

## ✅ 풀이 아이디어 요약

1. 로봇이 **한 번에 칠 수 있는 거리들**은 리스트로 주어집니다.
2. 우리는 그 거리들을 **1번 또는 2번 합해서** 홀까지 도달할 수 있는지를 판단해야 합니다.
3. 그런데 단순히 모든 두 거리 조합을 `이중 for문`으로 계산하면 **시간 초과**가 발생합니다.
   (최대 200,000개의 거리니까, O(N²)는 감당 불가)

그래서 등장하는 것이 **컨볼루션**과 **FFT**입니다.

---

## ❓ 컨볼루션이 뭐야?

컨볼루션은 "두 수의 합으로 만들 수 있는 경우의 수"를 빠르게 계산할 수 있는 수학적 도구입니다.

예를 들어 거리 배열 A = \[1, 3, 5]가 있을 때, A와 A를 곱하면:

```
(1+1), (1+3), (1+5), (3+1), (3+3), (3+5), (5+1), (5+3), (5+5)
```

이런 모든 조합을 빠르게 계산할 수 있는 방법이 **컨볼루션**이고, 그 컨볼루션을 빠르게 처리해주는 것이 \*\*FFT(Fast Fourier Transform)\*\*입니다.

---

## 💡 컨볼루션과 FFT의 관계

* 두 배열의 곱 = **각 요소 쌍의 곱의 누적합**입니다.
* 이것을 수학적으로 빠르게 계산하는 공식이 FFT입니다.
* 일반 곱셈이 O(N²)라면, FFT는 O(N log N)으로 줄여줍니다!

---

## 🧠 문제 해결 흐름

1. **주어진 거리 배열을 `freq`라는 배열로 표현**합니다.

   * 거리 i를 칠 수 있으면 `freq[i] = 1`
   * 나머지는 0

2. 이 `freq` 배열을 **자기 자신과 컨볼루션**합니다.
   → 결과: 두 번 칠 때 도달할 수 있는 거리들

3. 원래 `freq`에는 1번에 도달할 수 있는 거리들도 표시되어 있으므로,
   **1회 or 2회로 도달 가능한 모든 거리**를 표시한 `reachable` 배열을 만듭니다.

4. 이제 각 홀 거리 `d`가 `reachable[d] == true`인지만 확인하면 됩니다.

---

## 🔧 코드 요약

```swift
// 입력
let ks = [1, 3, 5]
let ds = [2, 4, 5, 7, 8, 9]

// 1. 한 번에 칠 수 있는 거리 표시
var freq = [Int](repeating: 0, count: 200_001)
for k in ks {
  freq[k] = 1
}

// 2. 컨볼루션 수행
let conv = convolution(freq, freq)

// 3. 도달 가능한 거리 저장
var reachable = [Bool](repeating: false, count: conv.count)
for i in 0..<freq.count where freq[i] == 1 {
  reachable[i] = true // 1회
}
for i in 0..<conv.count where conv[i] > 0 {
  reachable[i] = true // 2회
}

// 4. 정답 계산
let result = ds.filter { $0 < reachable.count && reachable[$0] }.count
print(result) // 4
```

---

## ⚙️ FFT는 어떻게 구현했을까?

Swift 5.5는 복소수를 지원하지 않기 때문에 `Complex` 타입도 직접 만들었습니다:

```swift
struct Complex {
  var re: Double
  var im: Double
  ...
}
```

그리고 FFT는 아래 구조로 동작합니다:

1. 배열을 **짝수/홀수로 나누고**
2. 각각 재귀적으로 FFT 적용
3. **회전 인자(복소수)를 곱해서 합치기**
4. 역 FFT 시에는 모든 항을 `2`로 나눔

이 과정을 통해 매우 큰 배열의 곱을 빠르게 계산할 수 있습니다.

---

## 🎯 결론

| 방법         | 시간 복잡도     | 설명     |
| ---------- | ---------- | ------ |
| 브루트포스      | O(N²)      | 시간 초과  |
| 컨볼루션 + FFT | O(N log N) | 통과! ✔️ |

이 문제는 단순한 구현 문제처럼 보이지만, 사실 **고속 푸리에 변환을 실전에서 적용해야 하는 대표적인 문제**입니다.
수학적 배경을 몰라도 `이중합을 빠르게 계산할 수 있다`는 점만 기억하면 FFT를 문제 해결에 멋지게 활용할 수 있습니다.

---

## 📌 참고

* 문제 링크: [https://www.acmicpc.net/problem/10531](https://www.acmicpc.net/problem/10531)
* 관련 키워드: FFT, 컨볼루션, 복소수, 이산 푸리에 변환, 알고리즘 최적화

---
