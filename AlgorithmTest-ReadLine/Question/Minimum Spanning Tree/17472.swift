//
//  17472.swift
//  AlgorithmTest-ReadLine
//
//  Created by 윤범태 on 4/20/2024.
//
//  6: 다리 만들기 2 https://www.acmicpc.net/problem/17472
//

// import Foundation

/// 다리 만들기 2 https://www.acmicpc.net/problem/17472
func Q_17472() {
    // MARK: - 입력처리 및 문제풀이
    
    let r = readLine()!.split(separator: " ").map { Int($0)! }
    let (n, m) = (r[0], r[1])
    
    var map = (0..<n).map { _ in readLine()!.split(separator: " ").map { Int($0)! } }
    var visited = Array(repeating: Array(repeating: false, count: m), count: n)
    let dir4: [(y: Int, x: Int)] = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    var landCount = 1
    
    for i in 0..<n {
        for j in 0..<m where map[i][j] == 1 && !visited[i][j] {
            bfs_landNumbering(i, j, landCount)
            landCount += 1
        }
    }
    
    typealias Edge = (weight: Int, from: Int, to: Int)
    var edges = [Edge]()
    
    for i in 0..<n {
        for j in 0..<m where map[i][j] != 0 {
            bfs_makeBridge(i, j, map[i][j])
        }
    }
    
    edges.sort(by: { $0.weight < $1.weight }) // MST 크루스칼 탐색을 위해 가중치 오름차순 정렬
    print(landCount, map)
    // bfs_makeBridge 작업을 완료하면 landCount가 실제 섬 개수보다 1 크게 나오기 때문에 감소시킨다.
    landCount -= 1
    var unf = Array(0...landCount)
    
    let result = mst_shortestPath()
    print(result == 0 ? -1 : result)

    // MARK: - 1: 맵 각 지역에 숫자 부여하기
     
    func bfs_landNumbering(_ y: Int, _ x: Int, _ i: Int) {
        var q = [(y: y, x: x)], sIdx = 0
        map[y][x] = i
        visited[y][x] = true
        
        while sIdx < q.count {
            let pop = q[sIdx]; sIdx += 1
            
            for dir in dir4 {
                let (ny, nx) = (pop.y + dir.y, pop.x + dir.x)
                
                if nx < 0 || ny < 0 || nx >= m || ny >= n {
                    continue
                }
                
                if !visited[ny][nx], map[ny][nx] == 1 {
                    map[ny][nx] = i
                    visited[ny][nx] = true
                    q.append((ny, nx))
                }
            }
        }
    }
    
    // MARK: - 2: 섬과 섬 사이의 최단 거리 구하기 (다리 만들기)
    
    func bfs_makeBridge(_ y: Int, _ x: Int, _ i: Int) {
        visited = Array(repeating: Array(repeating: false, count: m), count: n)
        
        for dir in dir4 {
            var q = [(y: Int, x: Int, move: Int)](), sIdx = 0
            
            q.append((y, x, 0))
            visited[y][x] = true
            
            while sIdx < q.count {
                let pop = q[sIdx]; sIdx += 1
                let (ny, nx) = (pop.y + dir.y, pop.x + dir.x)
                
                if ny < 0 || nx < 0 || ny > n - 1 || nx > m - 1 {
                    continue
                }
                
                if visited[ny][nx] {
                    continue
                }
                
                if map[ny][nx] != i, map[ny][nx] != 0 {
                    let from = i - 1
                    let to = map[ny][nx] - 1
                    let bridgeLength = pop.move
                    
                    if bridgeLength > 1 {
                        edges.append((bridgeLength, from, to))
                        break
                    }
                } else if map[ny][nx] != i {
                    visited[ny][nx] = true
                    q.append((ny, nx, pop.move + 1))
                }
            }
        }
    }
    
    // MARK: - 3: 섬과 섬사이를 잇는 모든 다리 길이의 최소값 구하기 (MST)
    
    func find(_ x: Int) -> Int {
        guard unf[x] != x else {
            return x
        }
        
        unf[x] = find(unf[x])
        return unf[x]
    }
    
    func union(_ x: Int, _ y: Int) {
        let (x, y) = (find(x), find(y))
        
        guard x != y else {
            return
        }
        
        if x < y {
            unf[y] = x
        } else {
            unf[x] = y
        }
    }
    
    func mst_shortestPath() -> Int {
        var wSum = 0
        
        for i in edges.indices where find(edges[i].from) != find(edges[i].to) {
            let (w, from, to) = edges[i]
            wSum += w
            union(from, to)
        }
        
        // 연결이 안 된 경우: unf[0]의 값과 unf[i] 부모 값이 일치하지 않으면 연결이 안된 것이므로 0을 반환
        for i in 1..<landCount where unf[0] != find(unf[i]) {
            return 0
        }
        
        return wSum
    }
}

/*
 [풀이] https://loosie.tistory.com/262
 1. 섬을 구분한다.
  - BFS를 사용한다. (그래프의 구역 구분은 보통 BFS를 사용)
  - 영역이 1인 곳을 탐색하여 서로 다른 인덱스 값으로 구분시킨다.
 
 2. 섬과 섬 사이의 최단 거리(다리; 거리 => 가중치)를 구한다.
  - 섬마다 탐색을 들어가서 바다 방향 쪽으로 총 4번의 BFS 탐색을 한 뒤 최단 거리를 구한다.
  - 다리의 종류는 가로, 세로 총 2가지의 양방향 다리이다.
    - 하나의 정점에서 네 가지의 다리가 설차되는지 확인한다.
     ⬜️🔼⬜️⬜️⬜️⬜️
     ⬜️⏹️⬜️⬜️⬜️⬜️
     ◀️🟩⏹️⏹️▶️⬜️  (y, x) 정점을 기준으로 4방향 모두 탐색
     ⬜️⏹️⬜️⬜️⬜️⬜️
     ⬜️⏹️⬜️⬜️⬜️⬜️
     ⬜️🔽⬜️⬜️⬜️⬜️
    - 각 정점마다 for문을 총 4번 돌려 각 방향으로 while문을 돌려 탐색
    - 길이가 2 이상부터 설계가 가능하므로 해당 부분에만 조건을 건다
    - 다리가 완성되었다면 해당 노드의 다리 길이(가중치)와 시작-끝점을 저장한다.
      => 크루스칼 알고리즘에서 사용하기 위함
      => 가중치를 기준으로 오름차순 정렬
    - visited 검사를 통해 중복 부분의 길이를 제외한다.
 
 3. 구한 가중치 정보로 섬과 섬 사이를 잇는 모든 다리 길이(가중치)의 최소 합을 구한다.
  - 그래프 내의 모든 정점을 포함하면서, 가중치(다리 길이)를 최소로 한 경로를 구해야 한다.
  - 단 사이클은 이루어지면 안된다.
    => 최소 신장 트리(MST)를 사용해 구한다.
 
 [참고]
 - BFS, MST 문제가 결합된 종합문제
 
 --------
 
 문제
 섬으로 이루어진 나라가 있고, 모든 섬을 다리로 연결하려고 한다. 이 나라의 지도는 N×M 크기의 이차원 격자로 나타낼 수 있고, 격자의 각 칸은 땅이거나 바다이다.

 섬은 연결된 땅이 상하좌우로 붙어있는 덩어리를 말하고, 아래 그림은 네 개의 섬으로 이루어진 나라이다. 색칠되어있는 칸은 땅이다.
 
 ⬜️⬜️⬜️⬜️⬜️⬜️🟩🟩
 🟩🟩⬜️⬜️⬜️⬜️🟩🟩
 🟩🟩⬜️⬜️⬜️⬜️⬜️⬜️
 🟩🟩⬜️⬜️⬜️🟩🟩⬜️
 ⬜️⬜️⬜️⬜️⬜️🟩🟩⬜️
 ⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️
 🟩🟩🟩🟩🟩🟩🟩🟩
 
 다리는 바다에만 건설할 수 있고, 다리의 길이는 다리가 격자에서 차지하는 칸의 수이다. 다리를 연결해서 모든 섬을 연결하려고 한다. 섬 A에서 다리를 통해 섬 B로 갈 수 있을 때, 섬 A와 B를 연결되었다고 한다. 다리의 양 끝은 섬과 인접한 바다 위에 있어야 하고, 한 다리의 방향이 중간에 바뀌면 안된다. 또, 다리의 길이는 2 이상이어야 한다.

 다리의 방향이 중간에 바뀌면 안되기 때문에, 다리의 방향은 가로 또는 세로가 될 수 밖에 없다. 방향이 가로인 다리는 다리의 양 끝이 가로 방향으로 섬과 인접해야 하고, 방향이 세로인 다리는 다리의 양 끝이 세로 방향으로 섬과 인접해야 한다.

 섬 A와 B를 연결하는 다리가 중간에 섬 C와 인접한 바다를 지나가는 경우에 섬 C는 A, B와 연결되어있는 것이 아니다.

 아래 그림은 섬을 모두 연결하는 올바른 2가지 방법이고, 다리는 회색으로 색칠되어 있다. 섬은 정수, 다리는 알파벳 대문자로 구분했다.
 
 ⬜️⬜️⬜️⬜️⬜️⬜️2️⃣2️⃣      다리의 총 길이: 13
 1️⃣1️⃣🅰️🅰️🅰️🅰️2️⃣2️⃣      D는 2와 4를 연결하는 다리이고, 3과는 연결되어 있지 않다.
 1️⃣1️⃣⬜️⬜️⬜️⬜️⬜️🆔
 1️⃣1️⃣🅱️🅱️🅱️3️⃣3️⃣🆔
 ⬜️🆑⬜️⬜️⬜️3️⃣3️⃣🆔
 ⬜️🆑⬜️⬜️⬜️⬜️⬜️🆔
 4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣
 
 ⬜️⬜️⬜️⬜️⬜️⬜️2️⃣2️⃣      다리의 총 길이: 9 (최소)
 1️⃣1️⃣🅰️🅰️🅰️🅰️2️⃣2️⃣
 1️⃣1️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 1️⃣1️⃣🅱️🅱️🅱️3️⃣3️⃣⬜️
 ⬜️🆑⬜️⬜️⬜️3️⃣3️⃣⬜️
 ⬜️🆑⬜️⬜️⬜️⬜️⬜️⬜️
 4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣
 
 다음은 올바르지 않은 3가지 방법이다.
 
 ⬜️⬜️⬜️⬜️⬜️⬜️2️⃣2️⃣      B의 방향이 중간에 바뀌었다.
 1️⃣1️⃣🅰️🅰️🅰️🅰️2️⃣2️⃣
 1️⃣1️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 1️⃣1️⃣⬜️⬜️⬜️3️⃣3️⃣⬜️
 ⬜️🆑⬜️🅱️🅱️3️⃣3️⃣⬜️
 ⬜️🆑⬜️🅱️⬜️⬜️⬜️⬜️
 4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣
 
 ⬜️⬜️⬜️⬜️⬜️⬜️2️⃣2️⃣      D의 길이가 1이다.
 1️⃣1️⃣🅰️🅰️🅰️🅰️2️⃣2️⃣
 1️⃣1️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 1️⃣1️⃣🅱️🅱️🅱️3️⃣3️⃣⬜️
 ⬜️🆑⬜️⬜️⬜️3️⃣3️⃣⬜️
 ⬜️🆑⬜️⬜️⬜️🆔⬜️⬜️
 4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣
 
 ⬜️🅰️🅰️🅰️🅰️🅰️2️⃣2️⃣      가로 다리인 A가 1과 가로로 연결되어 있지 않다.
 1️⃣1️⃣⬜️⬜️⬜️⬜️2️⃣2️⃣
 1️⃣1️⃣⬜️⬜️⬜️⬜️⬜️⬜️
 1️⃣1️⃣🅱️🅱️🅱️3️⃣3️⃣⬜️
 ⬜️🆑⬜️⬜️⬜️3️⃣3️⃣⬜️
 ⬜️🆑⬜️⬜️⬜️🆔⬜️⬜️
 4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣
 
 다리가 교차하는 경우가 있을 수도 있다. 교차하는 다리의 길이를 계산할 때는 각 칸이 각 다리의 길이에 모두 포함되어야 한다. 아래는 다리가 교차하는 경우와 기타 다른 경우에 대한 2가지 예시이다.
 
 ⬜️⬜️⬜️1️⃣1️⃣⬜️⬜️⬜️       A의 길이는 4이고, B의 길이도 4이다.
 ⬜️⬜️⬜️1️⃣1️⃣⬜️⬜️⬜️       총 다리의 총 길이: 4 + 4 + 2 = 10
 2️⃣2️⃣⬜️⬜️🅱️⬜️3️⃣3️⃣
 2️⃣2️⃣🅰️🅰️⚛️🅰️3️⃣3️⃣
 2️⃣2️⃣⬜️⬜️🅱️⬜️🆑⬜️
 ⬜️⬜️⬜️⬜️🅱️⬜️🆑⬜️
 4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣4️⃣
 
 1️⃣🆔🆔2️⃣2️⃣2️⃣⬜️⬜️       다리 A: 2와 3을 연결 (길이 2)
 ⬜️⬜️3️⃣🅰️⬜️🆑4️⃣4️⃣       다리 B: 3과 4를 연결 (길이 3)
 ⬜️⬜️3️⃣⚛️🅱️🚼4️⃣4️⃣       다리 C: 2와 5를 연결 (길이 5)
 ⬜️⬜️3️⃣3️⃣3️⃣🆑⬜️⬜️       다리 D: 1과 2를 연결 (길이 2)
 ⬜️⬜️⬜️⬜️⬜️🆑⬜️⬜️       총 길이: 12
 ⬜️5️⃣5️⃣5️⃣⬜️🆑⬜️⬜️
 5️⃣5️⃣5️⃣5️⃣5️⃣5️⃣⬜️⬜️
 
 나라의 정보가 주어졌을 때, 모든 섬을 연결하는 다리 길이의 최솟값을 구해보자.

 입력
 첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다.

 출력
 모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결하는 것이 불가능하면 -1을 출력한다.

 제한
 1 ≤ N, M ≤ 10
 3 ≤ N×M ≤ 100
 2 ≤ 섬의 개수 ≤ 6
 
 예제 입력 1
7 8
0 0 0 0 0 0 1 1
1 1 0 0 0 0 1 1
1 1 0 0 0 0 0 0
1 1 0 0 0 1 1 0
0 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1
 
 예제 출력 1
 9
 
 예제 입력 2
7 8
0 0 0 1 1 0 0 0
0 0 0 1 1 0 0 0
1 1 0 0 0 0 1 1
1 1 0 0 0 0 1 1
1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1
 예제 출력 2
 10
 
 예제 입력 3
7 8
1 0 0 1 1 1 0 0
0 0 1 0 0 0 1 1
0 0 1 0 0 0 1 1
0 0 1 1 1 0 0 0
0 0 0 0 0 0 0 0
0 1 1 1 0 0 0 0
1 1 1 1 1 1 0 0
 예제 출력 3
 9
 
 예제 입력 4
7 7
1 1 1 0 1 1 1
1 1 1 0 1 1 1
1 1 1 0 1 1 1
0 0 0 0 0 0 0
1 1 1 0 1 1 1
1 1 1 0 1 1 1
1 1 1 0 1 1 1
 예제 출력 4
 -1
 
 [반례]
4 4
0 1 0 1
1 0 0 1
1 0 0 1
1 1 1 1
 ans : 2
 
8 8
1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 1 1 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1
 답: 2
 
8 8
0 0 0 1 1 1 1 0
0 1 1 1 1 0 1 0
0 1 0 1 1 1 0 0
0 1 0 0 0 1 0 0
0 0 0 1 0 0 1 0
0 0 0 0 0 1 0 0
0 1 1 1 0 0 0 0
0 1 0 0 0 1 0 0
 답: -1
 
6 10
1 1 1 1 1 1 1 1 1 1
1 0 0 0 0 0 1 0 0 0
1 0 1 0 0 0 1 0 0 1
1 0 1 0 0 0 1 0 0 1
0 0 1 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1
 answer: 2
 */
